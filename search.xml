<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法学习（1）</title>
    <url>/2021/12/11/21/</url>
    <content><![CDATA[<h1 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h1><p><strong>有错还请指正</strong></p>
<span id="more"></span>
<h2 id="简单枚举"><a href="#简单枚举" class="headerlink" title="简单枚举"></a>简单枚举</h2><h3 id="例题7-1-除法（Division-UVa-725）"><a href="#例题7-1-除法（Division-UVa-725）" class="headerlink" title="例题7-1 除法（Division, UVa 725）"></a>例题7-1 除法（Division, UVa 725）</h3><p>输入正整数n，按从小到大的顺序输出所有形如abcde/fghij = n的表达式，其中a～j恰好 为数字0～9的一个排列（可以有前导0），2≤n≤79。 </p>
<p>样例输入： </p>
<p>62 </p>
<p>样例输出： </p>
<p>79546 / 01283 = 62 </p>
<p>94736 / 01528 = 62</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,n,s1,s2,flag[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1234</span>;i&lt;<span class="number">50000</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">            s1=i;</span><br><span class="line">            s2=i*n;</span><br><span class="line">            <span class="keyword">while</span>(s1||s2)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(!flag[s1%<span class="number">10</span>])</span><br><span class="line">                {</span><br><span class="line">                    flag[s1%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">                    s1/=<span class="number">10</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(!flag[s2%<span class="number">10</span>])</span><br><span class="line">                {</span><br><span class="line">                    flag[s2%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">                    s2/=<span class="number">10</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">              <span class="keyword">if</span>(!flag[j])</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">10</span>&amp;&amp;i*n&lt;=<span class="number">98765</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">10000</span>)</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"%d / 0%d = %d\n"</span>,i*n,i,n);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"%d / %d = %d\n"</span>,i*n,i,n);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="例题7-2-最大乘积（Maximum-Product-UVa-11059）"><a href="#例题7-2-最大乘积（Maximum-Product-UVa-11059）" class="headerlink" title="例题7-2 最大乘积（Maximum Product, UVa 11059）"></a>例题7-2 最大乘积（Maximum Product, UVa 11059）</h3><p>输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘 积不是正数，应输出0（表示无解）。1≤n≤18，-10≤Si≤10。 </p>
<p>样例输入： </p>
<p>3 </p>
<p>2 4 -3 </p>
<p>5 </p>
<p>2 5 -1 2 -1 </p>
<p>样例输出： </p>
<p>8 20</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> max=<span class="number">-1e19</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--){</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,a[<span class="number">20</span>]={<span class="number">0</span>},ret=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">			ret=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++){</span><br><span class="line">				ret=ret*a[k];</span><br><span class="line">		}</span><br><span class="line">			<span class="keyword">if</span>(ret&gt;max)</span><br><span class="line">			max=ret;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(max&lt;<span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max);</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="例题7-3-分数拆分（Fractions-Again-UVa-10976）"><a href="#例题7-3-分数拆分（Fractions-Again-UVa-10976）" class="headerlink" title="例题7-3 分数拆分（Fractions Again?!, UVa 10976）"></a>例题7-3 分数拆分（Fractions Again?!, UVa 10976）</h3><p>输入正整数k，找到所有的正整数x&gt;=y,使得1/k=1/x + 1/y;</p>
<p>样例输入：</p>
<p>2  </p>
<p>12  </p>
<p>样例输出：</p>
<p>2      </p>
<p>1/2 = 1/6 + 1/3；  </p>
<p>1/2 = 1/4 + 1/4；</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k)){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=k+<span class="number">1</span>;y&lt;=<span class="number">2</span>*k;y++){</span><br><span class="line">            <span class="keyword">if</span>(k*y%(y-k)==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">int</span> x = k*y/(y-k);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1/%d = 1/%d + 1/%d\n"</span>,k,x,y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从1/12=1/156+1/13可以看出，x可以比y大很多。由于x&gt;=y,有1/x&lt;=1/y,因此1/k-1/y&lt;=1/y，即<strong>y&lt;=2 * k</strong>.这样，只需要在2 * k范围之内枚举y，然后根据y尝试计算出x即可</p>
<h2 id="枚举排列"><a href="#枚举排列" class="headerlink" title="枚举排列"></a>枚举排列</h2><h3 id="7-2-1-生成1～n的排列"><a href="#7-2-1-生成1～n的排列" class="headerlink" title="7.2.1 生成1～n的排列"></a>7.2.1 生成1～n的排列</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A,<span class="keyword">int</span> cur)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(cur==n){</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">	<span class="keyword">int</span> ok=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cur;j++)</span><br><span class="line">	<span class="keyword">if</span>(A[j]==i)</span><br><span class="line">	ok=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(ok){</span><br><span class="line">	A[cur]=i;</span><br><span class="line">	print_permutation(n,A,cur+<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,cur=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	print_permutation(n,a,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然我知道c++STL里有next_permutation函数，这里是函数的一种实现方式（递归）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_pre</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  }<span class="keyword">while</span>(next_permutation(p,p+n));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-2-2-生成可重集的排列"><a href="#7-2-2-生成可重集的排列" class="headerlink" title="7.2.2 生成可重集的排列"></a>7.2.2 生成可重集的排列</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">30</span>],a[<span class="number">30</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>*x,<span class="keyword">int</span> pos)</span></span>{</span><br><span class="line">	<span class="keyword">if</span> (pos==n) {</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,x[i]); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">		<span class="keyword">if</span> (!i||(a[i]!=a[i<span class="number">-1</span>])){</span><br><span class="line">			<span class="keyword">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pos;j++) </span><br><span class="line">			<span class="keyword">if</span> (x[j]==a[i]) c1++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) </span><br><span class="line">			<span class="keyword">if</span> (a[i]==a[j]) c2++;</span><br><span class="line">			<span class="keyword">if</span> (c1&lt;c2) {</span><br><span class="line">			x[pos]=a[i];</span><br><span class="line">			<span class="built_in">print_permutation</span>(n,x,pos+<span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">	<span class="built_in">sort</span>(a,a+n); </span><br><span class="line">	<span class="built_in">print_permutation</span>(n,ans,<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-2-4-下一个排列"><a href="#7-2-4-下一个排列" class="headerlink" title="7.2.4 下一个排列"></a>7.2.4 下一个排列</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,p[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">	<span class="built_in">sort</span>(p, p+n);</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(p, p+n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>待更新。。。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（1）</title>
    <url>/2021/12/19/22/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span>
<p>数据结构可以说是学习算法的前提，我将在寒假前后更新完数据结构相关的内容，同时会更新一些简单的算法，我学习的是mooc上浙大的<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1465570445#/learn/announce">数据结构</a></p>
<h1 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><p><strong>“线性表(Linear List)”</strong>：由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>
<p>表中元素个数称为线性表的<strong>长度</strong>；线性表没有元素时，称为<strong>空表</strong>；表起始位置称<strong>表头</strong>，表结束位置称<strong>表尾</strong></p>
<h2 id="对线性表的操作"><a href="#对线性表的操作" class="headerlink" title="对线性表的操作"></a>对线性表的操作</h2><p>1、<strong>List MakeEmpty()</strong> 初始化一个空线性表L</p>
<p>2、<strong>ElementType FindKth( int K, List L )</strong> 根据位序K，返回相应元素</p>
<p>3、<strong>int Find( ElementType X, List L )</strong> 在线性表L中查找X的第一次出现位置</p>
<p>4、<strong>void Insert( ElementType X, int i, List L)</strong> 在位序i前插入一个新元素X</p>
<p>5、<strong>void Delete( int i, List L )</strong> 删除指定位序i的元素；</p>
<p>6、<strong>int Length( List L )</strong> 返回线性表L的长度n</p>
<h2 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h2><h3 id="建立空的顺序表"><a href="#建立空的顺序表" class="headerlink" title="建立空的顺序表"></a>建立空的顺序表</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">( )</span></span>{</span><br><span class="line">    List PtrL;</span><br><span class="line">	PtrL = (List )<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode) );</span><br><span class="line"> 	PtrL-&gt;Last = <span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">return</span> PtrL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">( ElementType X, List PtrL )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span>( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X )</span><br><span class="line"> 	i++;</span><br><span class="line"> 	<span class="keyword">if</span> (i &gt; PtrL-&gt;Last) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 如果没找到，返回-1 */</span></span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">return</span> i; <span class="comment">/* 找到后返回的是存储位置 */</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( ElementType X, <span class="keyword">int</span> i, List PtrL )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"> 	<span class="keyword">if</span> ( PtrL-&gt;Last == MAXSIZE<span class="number">-1</span> ){ <span class="comment">/* 表空间已满，不能插入*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(＂表满＂); </span><br><span class="line"> 	<span class="keyword">return</span>; </span><br><span class="line"> }</span><br><span class="line"> 	<span class="keyword">if</span> ( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">2</span>) { <span class="comment">/*检查插入位置的合法性*/</span></span><br><span class="line"> 	<span class="built_in">printf</span>(＂位置不合法＂);</span><br><span class="line"> 	<span class="keyword">return</span>; </span><br><span class="line"> }</span><br><span class="line"> 	<span class="keyword">for</span> ( j = PtrL-&gt;Last; j &gt;= i<span class="number">-1</span>; j-- )</span><br><span class="line"> 	PtrL-&gt;Data[j+<span class="number">1</span>] = PtrL-&gt;Data[j]; <span class="comment">/*将 ai～ an倒序向后移动*/</span></span><br><span class="line"> 	PtrL-&gt;Data[i<span class="number">-1</span>] = X; <span class="comment">/*新元素插入*/</span></span><br><span class="line"> 	PtrL-&gt;Last++; <span class="comment">/*Last仍指向最后元素*/</span></span><br><span class="line"> 	<span class="keyword">return</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">( <span class="keyword">int</span> i, List PtrL )</span></span>{ </span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"> 	<span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">1</span> ) { <span class="comment">/*检查空表及删除位置的合法性*/</span></span><br><span class="line"> 	<span class="built_in">printf</span> (“不存在第%d个元素”, i ); </span><br><span class="line"> 	<span class="keyword">return</span> ; </span><br><span class="line"> }</span><br><span class="line"> 	<span class="keyword">for</span> ( j = i; j &lt;= PtrL-&gt;Last; j++ )</span><br><span class="line"> 	PtrL-&gt;Data[j<span class="number">-1</span>] = PtrL-&gt;Data[j]; <span class="comment">/*将 ai+1～ an顺序向前移动*/</span></span><br><span class="line"> 	PtrL-&gt;Last--; <span class="comment">/*Last仍指向最后元素*/</span></span><br><span class="line"> 	<span class="keyword">return</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h2 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h2><h3 id="定义结构类型"><a href="#定义结构类型" class="headerlink" title="定义结构类型"></a>定义结构类型</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>{</span> </span><br><span class="line"> ElementType Data; </span><br><span class="line"> List Next;</span><br><span class="line">}; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span> <span class="params">( List PtrL )</span></span>{ </span><br><span class="line">    List p = PtrL; <span class="comment">/* p指向表的第一个结点*/</span></span><br><span class="line"> 	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span> ( p ) { </span><br><span class="line"> 	p = p-&gt;Next; </span><br><span class="line"> 	j++; <span class="comment">/* 当前p指向的是第 j 个结点*/</span></span><br><span class="line"> } </span><br><span class="line"> 	<span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><h4 id="（1）按序号查找-FindKth"><a href="#（1）按序号查找-FindKth" class="headerlink" title="（1）按序号查找: FindKth"></a>（1）按序号查找: FindKth</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">( <span class="keyword">int</span> K, List PtrL )</span></span>{ </span><br><span class="line">    List p = PtrL;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i &lt; K ){</span><br><span class="line"> 	p = p-&gt;Next;</span><br><span class="line"> 	i++; </span><br><span class="line"> }</span><br><span class="line"> 	<span class="keyword">if</span> ( i == K ) <span class="keyword">return</span> p; </span><br><span class="line"> 	<span class="comment">/* 找到第K个，返回指针 */</span></span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> 	<span class="comment">/* 否则返回空 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="（2）按值查找-Find-更常用"><a href="#（2）按值查找-Find-更常用" class="headerlink" title="（2）按值查找: Find(更常用)"></a>（2）按值查找: Find(更常用)</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Find</span><span class="params">( ElementType X, List PtrL )</span></span>{ </span><br><span class="line"> 	List p = PtrL;</span><br><span class="line"> 	<span class="keyword">while</span> ( p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X )</span><br><span class="line"> 	p = p-&gt;Next; </span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>先做s-&gt;Next = p-&gt;Next，后做p-&gt;Next = s，不要写反了</p>
<img src="/2021/12/19/22/1.jpg" class="" title="blog">
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">( ElementType X, <span class="keyword">int</span> i, List PtrL )</span></span>{ </span><br><span class="line">    List p, s;</span><br><span class="line"> 	<span class="keyword">if</span> ( i == <span class="number">1</span> ) { <span class="comment">/* 新结点插入在表头 */</span></span><br><span class="line"> 	s = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode)); <span class="comment">/*申请、填装结点*/</span></span><br><span class="line"> 	s-&gt;Data = X; </span><br><span class="line"> 	s-&gt;Next = PtrL;</span><br><span class="line"> 	<span class="keyword">return</span> s; <span class="comment">/*返回新表头指针*/</span></span><br><span class="line"> }</span><br><span class="line"> 	p = <span class="built_in">FindKth</span>( i<span class="number">-1</span>, PtrL ); <span class="comment">/* 查找第i-1个结点 */</span></span><br><span class="line"> 	<span class="keyword">if</span> ( p == <span class="literal">NULL</span> ) { <span class="comment">/* 第i-1个不存在，不能插入 */</span></span><br><span class="line"> 	<span class="built_in">printf</span>(＂参数i错＂);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> }<span class="keyword">else</span> {</span><br><span class="line"> 	s = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode)); <span class="comment">/*申请、填装结点*/</span></span><br><span class="line"> 	s-&gt;Data = X; </span><br><span class="line"> 	s-&gt;Next = p-&gt;Next; <span class="comment">/*新结点插入在第i-1个结点的后面*/</span></span><br><span class="line"> 	p-&gt;Next = s; </span><br><span class="line"> 	<span class="keyword">return</span> PtrL;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>malloc后肯定要free了，下面三个步骤最关键</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">s = p-&gt;Next; <span class="comment">/*s指向第i个结点*/</span></span><br><span class="line">p-&gt;Next = s-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line"><span class="built_in">free</span>(s); <span class="comment">/*释放被删除结点 */</span></span><br></pre></td></tr></tbody></table></figure>
<img src="/2021/12/19/22/2.jpg" class="" title="blog">
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">( <span class="keyword">int</span> i, List PtrL )</span></span>{ </span><br><span class="line">    List p, s;</span><br><span class="line"> 	<span class="keyword">if</span> ( i == <span class="number">1</span> ) { <span class="comment">/* 若要删除的是表的第一个结点 */</span></span><br><span class="line"> 	s = PtrL; <span class="comment">/*s指向第1个结点*/</span></span><br><span class="line"> 	<span class="keyword">if</span> (PtrL!=<span class="literal">NULL</span>) PtrL = PtrL-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="built_in">free</span>(s); <span class="comment">/*释放被删除结点 */</span></span><br><span class="line"> 	<span class="keyword">return</span> PtrL;</span><br><span class="line"> }</span><br><span class="line"> 	p = <span class="built_in">FindKth</span>( i<span class="number">-1</span>, PtrL ); <span class="comment">/*查找第i-1个结点*/</span></span><br><span class="line"> 	<span class="keyword">if</span> ( p == <span class="literal">NULL</span> ) { </span><br><span class="line"> 	<span class="built_in">printf</span>(“第%d个结点不存在”, i<span class="number">-1</span>); <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> } <span class="keyword">else</span> <span class="keyword">if</span> ( p-&gt;Next == <span class="literal">NULL</span> ){ </span><br><span class="line"> 	<span class="built_in">printf</span>(“第%d个结点不存在”, i); <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line"> 	s = p-&gt;Next; <span class="comment">/*s指向第i个结点*/</span></span><br><span class="line"> 	p-&gt;Next = s-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line"> 	<span class="built_in">free</span>(s); <span class="comment">/*释放被删除结点 */</span></span><br><span class="line"> 	<span class="keyword">return</span> PtrL;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广；对于线性表而言， n个元素都是基本的单元素；广义表中，这些元素不仅可以是单元素也可以是<strong>另一个广义表</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">GList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>{</span></span><br><span class="line"> <span class="keyword">int</span> Tag; <span class="comment">/*标志域：0表示结点是单元素，1表示结点是广义表 */</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> {</span> <span class="comment">/*子表指针域Sublist与单元素数据域Data复用（union类型），即共用存储空间*/</span></span><br><span class="line"> ElementType Data;</span><br><span class="line"> GList SubList; </span><br><span class="line"> } URegion;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h2><p>广义表就是多重链表的一种</p>
<p>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</p>
<p>但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表</p>
<p>多重链表有广泛的用途： 基本上如树、图这样相对复杂的数据结构都可以采 用多重链表方式实现存储</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>主题由nexT更换到了Butterfly</title>
    <url>/2021/12/29/23/</url>
    <content><![CDATA[<h2 id="无法挽回的错误"><a href="#无法挽回的错误" class="headerlink" title="无法挽回的错误"></a>无法挽回的错误</h2><p>昨天夜里想给博客增添一点新功能，没有备份主题配置文件，发布时出了问题，导致页面不显示了，无奈之下更换了Butterfly主题</p>
<p>令我意外的是这个主题的代码块自带mac风格</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>只不过gittalk要重新设置了，我也真是爱折腾。。。</p>
]]></content>
      <tags>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title>琐事记（1）</title>
    <url>/2021/12/31/24/</url>
    <content><![CDATA[<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p><strong>世间好物不坚牢，彩云易散琉璃脆。</strong></p>
<p><strong>—白居易《简简吟》</strong></p>
<h2 id="第一章-旧忆"><a href="#第一章-旧忆" class="headerlink" title="第一章 旧忆"></a>第一章 旧忆</h2><p>常常梦到春天里断了线的风筝，夏日里碧绿池塘边的蛙鸣，秋天里晒了满院的玉米，冬日里煤球炉中温暖的火苗……</p>
<p>我那思绪也像断了线的风筝，乘着自由的风，邂逅一幕幕回忆。</p>
<p>一切故事仿佛都是从冬天开始的，冬天对我而言象征着温暖的相聚，而春天则是怀着希望的分别，不论结果如何，年底一家人总会相聚一团，和和气气，畅叙往事。</p>
<p>从故乡到第一次走出家门，我们家就已经做好了用勤劳的双手换取幸福生活的准备。在西辛庄，我母亲挣得第一笔金，她说，那个加班的夜晚她永远也不会忘记；在昆山，母亲仅用几天时间就赶上了工厂机器运转的速度，母亲说了一句让我永远忘不了的话：“别人能做，我也可以！”在濮阳，母亲服务员的工作一干就是七年，生活越来月可观了，家里盖起了二层楼，往日的负债一一还清，仿佛什么样的累活都难不倒我的母亲，直到我第一次听到母亲说脚疼的只能慢慢得走路，第一次看到母亲滑倒差点再也没起来，第一次看到母亲失眠……我方才发现，那个无比坚强的母亲，老了。常年陪在母亲身边，却不知母亲常去染头是为了掩盖岁月的痕迹，脚疼去医院被检查出来是骨质增生，母亲又独自消化了多少疼痛和孤独？</p>
<p>父亲常年打工在外，记得高中放假每次都是母亲接我，不曾料到有一次父亲专门赶回家来接我，我在校门口等了两个小时，愣是没认出来父亲。“那是我爸吗，我真没认出来！”“你不知道你爸额头上添了多少皱纹和黑斑……”</p>
<img src="/2021/12/31/24/2.jpg" class="" title="blog">
<p>如今的年，也失色了不少。以往的除夕夜的天空，是烟花的舞台：每一次轰鸣，每一簇火花，每一次绽放，携卷着人们一年的烦恼与不幸，冲向穹顶，化作星光万丈。手里捧一碗热乎的饺子，便会震起层层涟漪。那些过往的人和事，兴许仍记得，兴许早已忘记了，都融进这新年的梦里。梦醒时，天朗气清，一切如初。</p>
]]></content>
      <tags>
        <tag>memories</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假冬训营字符串专题题解</title>
    <url>/2022/01/08/25/</url>
    <content><![CDATA[<h1 id="字符串专题第22组题解"><a href="#字符串专题第22组题解" class="headerlink" title="字符串专题第22组题解"></a>字符串专题第22组题解</h1><h2 id="A-雷同检测"><a href="#A-雷同检测" class="headerlink" title="A - 雷同检测"></a>A - 雷同检测</h2><p>考试的时候老师最讨厌有人抄袭了。自从有了电子评卷，老师要查找雷同卷，就容易多了，只要将两个人的答案输入计算机，进行逐个字符的比对，把相同的位置都找出来，就一目了然了。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>2 行，每行包含一串字符（长度不超过 200）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>1 行，包含若干个以空格分隔的数字，表示出现相同字符的位置。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">I am  suantoujun.</span><br><span class="line">I am  huayemei.</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 9</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">210</span>],b[<span class="number">210</span>];</span><br><span class="line">	gets(a),gets(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[i]==b[i])</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="B-首字母大写"><a href="#B-首字母大写" class="headerlink" title="B - 首字母大写"></a>B - 首字母大写</h2><p>对一个字符串中的所有单词，如果单词的首字母不是大写字母，则把单词的首字母变成大写字母。在字符串中，单词之间通过空白符分隔，空白符包括：空格(‘ ‘)、制表符(‘\t’)、回车符(‘\r’)、换行符(‘\n’)。</p>
<p>Input</p>
<p>输入一行：待处理的字符串（长度小于80）。</p>
<p>Output</p>
<p>输出一行：转换后的字符串。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if so, you already have a google account. you can sign in on the right.</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">If So, You Already Have A Google Account. You Can Sign In On The Right.</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">90</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,a);</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>]&gt;=<span class="string">'a'</span>&amp;&amp;a[<span class="number">0</span>]&lt;=<span class="string">'z'</span>)</span><br><span class="line">	a[<span class="number">0</span>]-=<span class="number">32</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(a)<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="string">' '</span>&amp;&amp;a[i+<span class="number">1</span>]&gt;=<span class="string">'a'</span>&amp;&amp;a[i+<span class="number">1</span>]&lt;=<span class="string">'z'</span>)</span><br><span class="line">		a[i+<span class="number">1</span>]-=<span class="number">32</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="C-大小写转换"><a href="#C-大小写转换" class="headerlink" title="C - 大小写转换"></a>C - 大小写转换</h2><p> 读入一些字符串，将其中的小写字母转成大写字母（其他字符不变）。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>  输入为多行，每行为一个字符串，字符串只由字母和数字组成，长度不超过80。输入以“End of file”结束。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>  对于每行输入，输出转换后的字符串。</p>
<h2 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">ICPC2004</span><br><span class="line">12345abcde</span><br></pre></td></tr></tbody></table></figure>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">HELLO</span><br><span class="line">ICPC2004</span><br><span class="line">12345ABCDE</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">90</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a)==<span class="number">1</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;=<span class="string">'a'</span>&amp;&amp;a[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">			a[i]-=<span class="number">32</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="D-数字反转"><a href="#D-数字反转" class="headerlink" title="D - 数字反转"></a>D - 数字反转</h2><p>给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零(参见样例 2)。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共 1 行，一个整数 N。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共 1 行，一个整数，表示反转后的新数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>-1,000,000,000 &lt;= N &lt;= 1,000,000,000−1,000,000,000 &lt;= N &lt;= 1,000,000,000。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">321</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Input 2</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-380</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output 2</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-83</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n){</span><br><span class="line">        sum=sum*<span class="number">10</span>+n%<span class="number">10</span>;</span><br><span class="line">		n/=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="E-删除单词后缀"><a href="#E-删除单词后缀" class="headerlink" title="E - 删除单词后缀"></a>E - 删除单词后缀</h2><p>给定一个单词，如果该单词以<code>er</code>、<code>ly</code>或者<code>ing</code>后缀结尾， 则删除该后缀（题目保证删除后缀后的单词长度不为 0），否则不进行任何操作。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为 32）。</p>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出按照题目要求处理后的单词。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">referer</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">refer</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">40</span>];</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	l=<span class="built_in">strlen</span>(a)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[l]==<span class="string">'r'</span>&amp;&amp;a[l<span class="number">-1</span>]==<span class="string">'e'</span>||a[l]==<span class="string">'y'</span>&amp;&amp;a[l<span class="number">-1</span>]==<span class="string">'l'</span>)</span><br><span class="line">	a[l<span class="number">-1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[l<span class="number">-2</span>]==<span class="string">'i'</span>&amp;&amp;a[l<span class="number">-1</span>]==<span class="string">'n'</span>&amp;&amp;a[l]==<span class="string">'g'</span>)</span><br><span class="line">	a[l<span class="number">-2</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="F-判断字符串是否为回文"><a href="#F-判断字符串是否为回文" class="headerlink" title="F - 判断字符串是否为回文"></a>F - 判断字符串是否为回文</h2><p>输入一个字符串，输出该字符串是否回文。回文是指顺读和倒读都一样的字符串。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入为一行字符串（字符串中没有空白字符，字符串长度不超过 100）。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果字符串是回文，输出<code>"yes"</code>；否则，输出<code>"no"</code>。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abcdedcba</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">110</span>];</span><br><span class="line">	<span class="keyword">int</span> len,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	len=<span class="built_in">strlen</span>(a)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[len-i]!=a[i])</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=len/<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"no"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"yes"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="G-基础数据结构——栈（1）"><a href="#G-基础数据结构——栈（1）" class="headerlink" title="G - 基础数据结构——栈（1）"></a>G - 基础数据结构——栈（1）</h2><p>给你一串字符，不超过50个字符，可能包括括号、数字、字母、标点符号、空格，你的任务是检查这一串字符中的( ) ,[ ],{ }是否匹配。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据有多组，每组数据不超过100个字符并含有( ,) ,[, ],{, }一个或多个。处理到文件结束。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果匹配就输出<code>"yes"</code>，不匹配输出<code>"no"</code></p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sin(20+10)</span><br><span class="line">{[}]</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">no</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">60</span>],c[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">gets</span>(s)<span class="comment">/*!=NULL*/</span>){</span><br><span class="line">        <span class="keyword">int</span> i,top=<span class="number">0</span>,l=<span class="built_in">strlen</span>(s);<span class="comment">//top代表栈顶</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">'['</span>||s[i]==<span class="string">'{'</span>){</span><br><span class="line">                c[top]=s[i];</span><br><span class="line">                top++;<span class="comment">//遇到前括号就入栈</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span>||s[i]==<span class="string">']'</span>||s[i]==<span class="string">'}'</span>){</span><br><span class="line">                <span class="keyword">if</span>(s[i]==c[top<span class="number">-1</span>]+<span class="number">1</span>||s[i]==c[top<span class="number">-1</span>]+<span class="number">2</span>){<span class="comment">//根据ascll码值找关系（40，41，91，93，123，125）</span></span><br><span class="line">                    top--;<span class="comment">//匹配成功就一块出栈</span></span><br><span class="line">                }</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i==l&amp;&amp;!top)<span class="comment">//最后栈空就说明全匹配成功了</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"yes"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"no"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="H-字典序"><a href="#H-字典序" class="headerlink" title="H - 字典序"></a>H - 字典序</h2><p>给你两个不同的字符串，如果第一个字符串的字典序小于第二个字符串，则输出YES，如果第一个字符串的字典序大于第二个字符串，则输出NO。</p>
<p>Input</p>
<p>两行。第一行一个字符串，第二行一个字符串。保证字符串的长度不超过10000。保证两个字符串不完全相等。</p>
<p>Output</p>
<p>如果第一个字符串的字典序小于第二个字符串，则输出YES，如果第一个字符串的字典序大于第二个字符串，则输出NO。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abe</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10010</span>],b[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a,b);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,b)&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="I-验证子串"><a href="#I-验证子串" class="headerlink" title="I - 验证子串"></a>I - 验证子串</h2><p>输入两个字符串，验证其中一个串是否为另一个串的子串。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入两个字符串， 每个字符串占一行，长度不超过 200 且不含空格。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>若第一个串 <em>s</em>1 是第二个串 <em>s</em>2 的子串，则输出<code>"(s1) is substring of (s2)"</code>；</p>
<p>否则，若第二个串 s2是第一个串s1的子串，输出<code>"(s2) is substring of (s1)"</code>；</p>
<p>否则，输出<code>"No substring"</code>。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">dddncabca</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abc is substring of dddncabca</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> l1,l2;</span><br><span class="line">	<span class="keyword">char</span> s1[<span class="number">210</span>],s2[<span class="number">210</span>];</span><br><span class="line">	gets(s1),gets(s2);</span><br><span class="line">	l1=<span class="built_in">strlen</span>(s1),l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	<span class="keyword">if</span>(l1&lt;l2&amp;&amp;<span class="built_in">strstr</span>(s2,s1))</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s is substring of %s"</span>,s1,s2);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(l1&gt;l2&amp;&amp;<span class="built_in">strstr</span>(s1,s2))</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s is substring of %s"</span>,s2,s1);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No substring"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="J-子串查找"><a href="#J-子串查找" class="headerlink" title="J - 子串查找"></a>J - 子串查找</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>这是一道模板题。</p>
<p>给定一个字符串 A 和一个字符串 <em>B</em>，求 B 在 A 中的出现次数。<em>A</em> 和 <em>B</em> 中的字符均为英语大写字母或小写字母。</p>
<p><em>A</em> 中不同位置出现的 <em>B</em> 可重叠。</p>
<h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，分别是字符串 A 和字符串 B。</p>
<h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 B 在 A 中的出现次数。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>zyzyzyz zyz</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>1 &lt;= A, B的长度 &lt;=10^6，A、B 仅包含大小写字母。</p>
<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000000</span></span><br><span class="line"><span class="keyword">char</span> s[M],p[M];</span><br><span class="line"><span class="keyword">int</span> nxt[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;p[i];i++){</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;p[j]!=p[i])</span><br><span class="line">		j=nxt[j];</span><br><span class="line">		nxt[i+<span class="number">1</span>]=p[j]==p[i]?++j:<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;s[i];i++){</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;p[j]!=s[i])</span><br><span class="line">			j=nxt[j];</span><br><span class="line">		<span class="keyword">if</span> (p[j]==s[i]&amp;&amp;++j==len){</span><br><span class="line">			tot++;</span><br><span class="line">			j=nxt[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,tot);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,s,p);</span><br><span class="line">	<span class="built_in">kmp</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="K-剪花布条"><a href="#K-剪花布条" class="headerlink" title="K - 剪花布条"></a>K - 剪花布条</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p>
<h4 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据为多组数据，读取到 <code>#</code> 字符时结束。每组数据仅有一行，为由空格分开的花布条和小饰条。花布条和小饰条都是用可见 ASCII 字符表示的，不会超过 1000 个字符。</p>
<p><strong>注意：这个 <code>#</code> 应为单个字符。若某字符串开头有 <code>#</code>，不意味着读入结束！</strong></p>
<h4 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，输出一行一个整数，表示能从花纹布中剪出的最多小饰条个数。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>abcde a3 aaaaaa aa #</td>
<td>0 3</td>
</tr>
</tbody>
</table>
</div>
<h4 id="数据范围与提示-1"><a href="#数据范围与提示-1" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>对于全部数据，字符串长度 ≤1000。</p>
<h3 id="1-用string代替char"><a href="#1-用string代替char" class="headerlink" title="1.用string代替char"></a>1.用string代替char</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s,t;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s){</span><br><span class="line">    	<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'#'</span>&amp;&amp;s[<span class="number">1</span>]==<span class="string">'\0'</span>)</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    	cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>,k=i;</span><br><span class="line">            <span class="keyword">while</span>(s[k]==t[j]&amp;&amp;k&lt;s.<span class="built_in">size</span>()){</span><br><span class="line">                ++k;++j;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j==t.<span class="built_in">size</span>()){</span><br><span class="line">                cnt++;</span><br><span class="line">                i=k<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-STL里的find函数"><a href="#2-STL里的find函数" class="headerlink" title="2.STL里的find函数"></a>2.STL里的find函数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s,t;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s&amp;&amp;!(s[<span class="number">0</span>]==<span class="string">'#'</span>&amp;&amp;s[<span class="number">1</span>]==<span class="string">'\0'</span>)){</span><br><span class="line">    	cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">find</span>(t)!=string::npos){		<span class="comment">//s.find(t)找不到会返回string::npos</span></span><br><span class="line">            cnt++;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(t),t.<span class="built_in">size</span>());	<span class="comment">//s.erase将已经找到的花布条剪掉</span></span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="L-最长回文子串"><a href="#L-最长回文子串" class="headerlink" title="L - 最长回文子串"></a>L - 最长回文子串</h2><p>输入一个字符串Str，输出Str里最长回文子串的长度。</p>
<p>回文串：指aba、abba、cccbccc、aaaa这种左右对称的字符串。</p>
<p>串的子串：一个串的子串指此（字符）串中<strong>连续</strong>的一部分字符构成的子（字符）串<br>例如 abc 这个串的子串：空串、a、b、c、ab、bc、abc</p>
<h4 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入Str（Str的长度 &lt;= 1000)</p>
<h4 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出最长回文子串的长度L。</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">daabaac</span><br></pre></td></tr></tbody></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<h3 id="中点扩散"><a href="#中点扩散" class="headerlink" title="中点扩散"></a>中点扩散</h3><p>O(n^2),为了代码简洁好看些doge,O(n)还是用哈希吧</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> l=i<span class="number">-1</span>,r=i+<span class="number">1</span>;<span class="comment">//这里要考虑到回文子串长度可能是偶数或奇数</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;str.<span class="built_in">length</span>()&amp;&amp;str[l]==str[r]){</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        }</span><br><span class="line">        res=<span class="built_in">max</span>(res,r-l<span class="number">-1</span>);</span><br><span class="line">        l=i,r=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;str.<span class="built_in">length</span>()&amp;&amp;str[l]==str[r]){</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        }</span><br><span class="line">        res=<span class="built_in">max</span>(res,r-l<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（2）</title>
    <url>/2022/01/12/26/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆栈（Stack）：</p>
<p>具有一定操作约束的线性表，只在一端（栈顶，Top）做插入、删除</p>
<p>特点：<strong>后入先出</strong></p>
<p>栈的操作：</p>
<p> 1、Stack CreateStack( int MaxSize )： 生成空堆栈，其最大长度为MaxSize；</p>
<p> 2、int IsFull( Stack S, int MaxSize )：判断堆栈S是否已满； </p>
<p> 3、void Push( Stack S, ElementType item )：将元素item压入堆栈；</p>
<p> 4、int IsEmpty ( Stack S )：判断堆栈S是否为空；</p>
<p> 5、ElementType Pop( Stack S )：删除并返回栈顶元素；</p>
<h2 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize <span class="comment">/*储存数据元素的最大个数*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>{</span></span><br><span class="line">	ElementType Data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> Top;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( Stack PtrS, ElementType item )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> 	<span class="keyword">if</span> ( PtrS-&gt;Top == MaxSize<span class="number">-1</span> ) {</span><br><span class="line"> 	<span class="built_in">printf</span>(“堆栈满”); <span class="keyword">return</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line"> 	PtrS-&gt;Data[++(PtrS-&gt;Top)] = item;</span><br><span class="line"> 	<span class="keyword">return</span>;</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack PtrS )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> 	<span class="keyword">if</span> ( PtrS-&gt;Top == <span class="number">-1</span> ) {</span><br><span class="line"> 	<span class="built_in">printf</span>(“堆栈空”);</span><br><span class="line"> 	<span class="keyword">return</span> ERROR; <span class="comment">/* ERROR是ElementType的特殊值，标志错误*/</span></span><br><span class="line"> 	} <span class="keyword">else</span> </span><br><span class="line"> 	<span class="built_in"><span class="keyword">return</span></span> ( PtrS-&gt;Data[(PtrS-&gt;Top)--] );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>{</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span></span><br><span class="line">} ;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="建栈"><a href="#建栈" class="headerlink" title="建栈"></a>建栈</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ <span class="comment">/* 构建一个堆栈的头结点，返回指针 */</span></span><br><span class="line"> 	Stack S;</span><br><span class="line"> 	S =(Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line"> 	S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"> 	<span class="keyword">return</span> S;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span></span><br><span class="line"><span class="function"></span>{ <span class="comment">/*判断堆栈S是否为空，若为空函数返回整数1，否则返回0 */</span></span><br><span class="line">	<span class="keyword">return</span> ( S-&gt;Next == <span class="literal">NULL</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( ElementType item, Stack S)</span> </span></span><br><span class="line"><span class="function"></span>{ <span class="comment">/* 将元素item压入堆栈S */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">	TmpCell=(struct SNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">	TmpCell-&gt;Element = item;</span><br><span class="line">	TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">	S-&gt;Next = TmpCell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>{ <span class="comment">/* 删除并返回堆栈S的栈顶元素 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">	ElementType TopElem;</span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( S ) ) {</span><br><span class="line">	<span class="built_in">printf</span>(“堆栈空”); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">	FirstCell = S-&gt;Next; </span><br><span class="line">    S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">	TopElem = FirstCell -&gt;Element;</span><br><span class="line">	<span class="built_in">free</span>(FirstCell);</span><br><span class="line">	<span class="keyword">return</span> TopElem;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>队列(Queue)：具有一定操作约束的线性表，只能在一端插入，而在另一端删除</p>
<p>特点：<strong>先进先出</strong></p>
<p>队列的操作：</p>
<p> 1、Queue CreatQueue( int MaxSize )：生成长度为MaxSize的空队列；</p>
<p> 2、int IsFullQ( Queue Q, int MaxSize )：判断队列Q是否已满；</p>
<p> 3、void AddQ( Queue Q, ElementType item )： 将数据元素item插入队列Q中；</p>
<p> 4、int IsEmptyQ( Queue Q )： 判断队列Q是否为空；</p>
<p> 5、ElementType DeleteQ( Queue Q )：将队头数据元素从队列中删除并返回。</p>
<h2 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize <span class="comment">/*储存数据元素的最大个数*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> {</span></span><br><span class="line">	ElementType Data[ MaxSize ];</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">}; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">( Queue PtrQ, ElementType item)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"> 	<span class="keyword">if</span> ( (PtrQ-&gt;rear+<span class="number">1</span>) % MaxSize == PtrQ-&gt;front ) {</span><br><span class="line"> 	<span class="built_in">printf</span>(“队列满”); </span><br><span class="line"> 	<span class="keyword">return</span>;</span><br><span class="line"> }</span><br><span class="line"> 	PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="number">1</span>)% MaxSize;</span><br><span class="line"> 	PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"> 	<span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear ) { </span><br><span class="line"> 	<span class="built_in">printf</span>(“队列空”);</span><br><span class="line"> 	<span class="keyword">return</span> ERROR;</span><br><span class="line"> 	} <span class="keyword">else</span> {</span><br><span class="line"> 	PtrQ-&gt;front = (PtrQ-&gt;front+<span class="number">1</span>)% MaxSize;</span><br><span class="line"> 	<span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line"> 	ElementType Data;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">}; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>{</span> <span class="comment">/* 链队列结构 */</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span> <span class="comment">/* 指向队尾结点 */</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">/* 指向队头结点 */</span></span><br><span class="line">}; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line">Queue PtrQ;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="出队列-1"><a href="#出队列-1" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span></span><br><span class="line"><span class="function"></span>{	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span> </span><br><span class="line"> 	ElementType FrontElem;</span><br><span class="line"> 	<span class="keyword">if</span> ( PtrQ-&gt;front == <span class="literal">NULL</span>) {</span><br><span class="line"> 	<span class="built_in">printf</span>(“队列空”); <span class="keyword">return</span> ERROR;</span><br><span class="line"> } </span><br><span class="line"> 	FrontCell = PtrQ-&gt;front;</span><br><span class="line"> 	<span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear) <span class="comment">/* 若队列只有一个元素 */</span></span><br><span class="line"> 	PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">/* 删除后队列置为空 */</span></span><br><span class="line"> 	<span class="keyword">else</span> </span><br><span class="line"> 	PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line"> 	FrontElem = FrontCell-&gt;Data;</span><br><span class="line"> 	<span class="built_in">free</span>( FrontCell ); <span class="comment">/* 释放被删除结点空间 */</span></span><br><span class="line"> 	<span class="keyword">return</span> FrontElem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假冬训营搜索专题题解</title>
    <url>/2022/01/13/27/</url>
    <content><![CDATA[<h1 id="搜索专题第22组题解"><a href="#搜索专题第22组题解" class="headerlink" title="搜索专题第22组题解"></a>搜索专题第22组题解</h1><p>写题之前你至少要搞懂<strong>深搜，广搜</strong>的原理，<strong>队列</strong>（先进先出）和<strong>栈</strong>（后进先出）的特点</p>
<p>深搜用堆栈存储，深搜的路径像面条一样，牺牲时间换空间，适用于求<strong>全部解</strong>的题等</p>
<p>广搜用队列存储，广搜的路径像水波一样，是往四周蔓延的，牺牲空间换时间，适用于求<strong>最短解</strong>的题等</p>
<h2 id="A-棋盘问题"><a href="#A-棋盘问题" class="headerlink" title="A - 棋盘问题"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/A">A - 棋盘问题</a></h2><font color="green">建议先看全排列</font>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">30</span>],n,k,sum,m;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(k==m){</span><br><span class="line">		sum++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(p&gt;=n)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">		<span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;a[p][j]==<span class="string">'#'</span>){</span><br><span class="line">			vis[j]=<span class="number">1</span>;<span class="comment">//依旧先标记后复原</span></span><br><span class="line">			m++;</span><br><span class="line">			<span class="built_in">dfs</span>(p+<span class="number">1</span>);</span><br><span class="line">			vis[j]=<span class="number">0</span>;</span><br><span class="line">			m--;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">dfs</span>(p+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)&amp;&amp;n!=<span class="number">-1</span>&amp;&amp;k!=<span class="number">-1</span>){</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		m=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="B-Perket"><a href="#B-Perket" class="headerlink" title="B - Perket"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/B">B - Perket</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">11</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">11</span>],b[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e11</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=N) </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">			<span class="keyword">if</span>(flag[i]==<span class="number">0</span>){</span><br><span class="line">				c*=a[i];<span class="comment">//依旧先标记后复原</span></span><br><span class="line">				y+=b[i];</span><br><span class="line">				flag[i]=<span class="number">1</span>;</span><br><span class="line">				ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(c-y));</span><br><span class="line">				<span class="built_in">dfs</span>(i+<span class="number">1</span>);</span><br><span class="line">				c/=a[i];</span><br><span class="line">				y-=b[i];</span><br><span class="line">				flag[i]=<span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++){</span><br><span class="line">		cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="C-全排列"><a href="#C-全排列" class="headerlink" title="C - 全排列"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/C">C - 全排列</a></h2><p>这里是字符全排列，不过和数字全排列没什么区别，用深搜遍历出每一种可能就行了，如果想省事，用c++里的next_permutation()函数就行了。</p>
<font color="blue">像这种经典题如果是第一次见，搞懂然后记住就完了</font>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">25</span>],b[<span class="number">25</span>];<span class="comment">//用a数组读入字符串，b数组记下路径</span></span><br><span class="line"><span class="keyword">int</span> n,vis[<span class="number">25</span>];<span class="comment">//标记数组，搜索过的数就标记好，防止重复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(p==n){</span><br><span class="line">		b[n]=<span class="string">'\0'</span>;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;endl;<span class="comment">//可以这样输出字符串</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//如果函数调用到第m层，for循环实际上也在dfs前进入到了第m轮，那剩下的(n-m)轮呢，就是用来产生分支的</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[i]){</span><br><span class="line">			vis[i]=<span class="number">1</span>;<span class="comment">//dfs前做好标记（记住）</span></span><br><span class="line">			b[p]=a[i];</span><br><span class="line">			<span class="built_in">dfs</span>(p+<span class="number">1</span>);</span><br><span class="line">			vis[i]=<span class="number">0</span>;<span class="comment">//dfs后删除标记,不同排列有相同数字，走的时候要取消标记（记住）</span></span><br><span class="line">		}</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	n=<span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);<span class="comment">//习惯上可以从0/1开始，和for循环里i的初值保持一致</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="D-自然数拆分"><a href="#D-自然数拆分" class="headerlink" title="D - 自然数拆分"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/D">D - 自然数拆分</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">41</span>],s,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout&lt;&lt;m&lt;&lt;<span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s<span class="number">-2</span>;i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d+"</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[s<span class="number">-1</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s,<span class="keyword">int</span> pre)</span><span class="comment">//pre确保要减的数是递增的</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;s&gt;<span class="number">1</span>){<span class="comment">//结束条件：进行至少一轮并且减完为零</span></span><br><span class="line">        <span class="built_in">pr</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pre;i&lt;=n;i++){</span><br><span class="line">        a[s]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(n-i,s+<span class="number">1</span>,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">dfs</span>(m,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="E-Prime-Ring-Problem"><a href="#E-Prime-Ring-Problem" class="headerlink" title="E - Prime Ring Problem"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/E">E - Prime Ring Problem</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">17</span>],id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;= <span class="built_in">sqrt</span>(n);i++){</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (x&gt;n&amp;&amp;<span class="built_in">prime</span>(a[x<span class="number">-1</span>]+a[<span class="number">1</span>])){<span class="comment">//要判断第一个数和最后一个数的和是否为素数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            cout&lt;&lt;a[i];</span><br><span class="line">            <span class="keyword">if</span> (i!=n)</span><br><span class="line">			cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">prime</span>(i+a[x<span class="number">-1</span>])&amp;&amp;!vis[i]){</span><br><span class="line">            vis[i]=<span class="literal">true</span>;</span><br><span class="line">            a[x]=i;</span><br><span class="line">            <span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">            vis[i]=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n){</span><br><span class="line">    	t++;</span><br><span class="line">    	<span class="keyword">if</span>(t&gt;=<span class="number">2</span>)</span><br><span class="line">    	cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Case "</span>&lt;&lt;++id&lt;&lt;<span class="string">":\n"</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="F-Red-and-Black"><a href="#F-Red-and-Black" class="headerlink" title="F - Red and Black"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/F">F - Red and Black</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> W,H;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">0</span>||x&gt;=W||y&lt;<span class="number">0</span>||y&gt;=H)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[x][y]==<span class="string">'#'</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        a[x][y]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">f</span>(x<span class="number">-1</span>,y)+<span class="built_in">f</span>(x+<span class="number">1</span>,y)+<span class="built_in">f</span>(x,y<span class="number">-1</span>)+<span class="built_in">f</span>(x,y+<span class="number">1</span>);<span class="comment">//求所以可走的路径，将和相加</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;H,&amp;W)&amp;&amp;W!=<span class="number">0</span>&amp;&amp;H!=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;W;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;W;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;H;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">'@'</span>) </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">f</span>(i, j));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="G-Knight-Moves"><a href="#G-Knight-Moves" class="headerlink" title="G - Knight Moves"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/G">G - Knight Moves</a></h2><p><strong>提醒一点，万能头虽好用，但里面有很多关键字可能会和你的变量名冲突，比如list,visit</strong></p>
<p>这道题应该用广搜，不知道c++队列操作的自行了解一下</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">302</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">horse</span>{</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">bool</span> Visit[len][len];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> way[<span class="number">8</span>][<span class="number">2</span>]={{<span class="number">-2</span>,<span class="number">-1</span>},{<span class="number">-1</span>,<span class="number">-2</span>},{<span class="number">1</span>,<span class="number">-2</span>},{<span class="number">2</span>,<span class="number">-1</span>},{<span class="number">2</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">2</span>},{<span class="number">-1</span>,<span class="number">2</span>},{<span class="number">-2</span>,<span class="number">1</span>}};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> e1,<span class="keyword">int</span> s2,<span class="keyword">int</span> e2,<span class="keyword">int</span> lenth)</span></span>{</span><br><span class="line">    queue&lt;horse&gt; q;</span><br><span class="line">    horse start,now,next;</span><br><span class="line">    start.x=s1;</span><br><span class="line">    start.y=e1;</span><br><span class="line">    start.step=<span class="number">0</span>;</span><br><span class="line">    Visit[start.x][start.y]=<span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">        now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.x==s2&amp;&amp;now.y==e2){</span><br><span class="line">            cout&lt;&lt;now.step&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line">            next.x=now.x+way[i][<span class="number">0</span>];</span><br><span class="line">            next.y=now.y+way[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;lenth&amp;&amp;next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;lenth&amp;&amp;!Visit[next.x][next.y]){</span><br><span class="line">                next.step=now.step+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(next);</span><br><span class="line">                Visit[next.x][next.y]=<span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        cin&gt;&gt;l;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        cin&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="built_in">memset</span>(Visit,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Visit));</span><br><span class="line">        <span class="built_in">bfs</span>(x1,y1,x2,y2,l);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="H-Oil-Deposits"><a href="#H-Oil-Deposits" class="headerlink" title="H - Oil Deposits"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/H">H - Oil Deposits</a></h2><p>这个题就是求矩阵中有多少个“分开”的区域，还可以变形为求最大面积等等</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,b,c;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++){<span class="comment">//这个写法爱了，这就是用循环表示8个方向</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++){</span><br><span class="line">            b=i+x;</span><br><span class="line">            c=y+j;</span><br><span class="line">            <span class="keyword">if</span>(b&gt;=<span class="number">0</span>&amp;&amp;b&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;a[b][c]==<span class="string">'@'</span>){<span class="comment">//如果遇到@就开始搜索并且把@变为*</span></span><br><span class="line">                a[b][c]=<span class="string">'*'</span>;<span class="comment">//这也算是一种标记</span></span><br><span class="line">                <span class="built_in">dfs</span>(b,c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF&amp;&amp;n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>){</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="string">'0'</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));<span class="comment">//学会用memset初始化数组，因为是字符数组，全初始化为字符0，防止上一轮残留数据的干扰</span></span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">'@'</span>){</span><br><span class="line">                    cnt++;<span class="comment">//遇到油层就要计数</span></span><br><span class="line">                    <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="I-Lake-Counting"><a href="#I-Lake-Counting" class="headerlink" title="I - Lake Counting"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/I">I - Lake Counting</a></h2><p>跟上一题一模一样，就是把@换成了w，*换成了.，并且无输入结束标志。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,b,c;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++){</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++){</span><br><span class="line">            b=i+x;</span><br><span class="line">            c=y+j;</span><br><span class="line">            <span class="keyword">if</span>(b&gt;=<span class="number">0</span>&amp;&amp;b&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;a[b][c]==<span class="string">'W'</span>){</span><br><span class="line">                a[b][c]=<span class="string">'.'</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(b,c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF){</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="string">'0'</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">'W'</span>){</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="J-二叉树先序遍历"><a href="#J-二叉树先序遍历" class="headerlink" title="J - 二叉树先序遍历"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/J">J - 二叉树先序遍历</a></h2><p>不知道什么是二叉数和先序遍历的先去查查，已经在计导书里学过了，思路很简单，定义一个包含左右节点的结构体，如果树非空，就做三个操作：</p>
<p>1：<strong>输出节点；</strong></p>
<p>2：<strong>先遍历左子树；</strong></p>
<p>3：<strong>之后遍历右子树，如果为空就返回上一层；</strong></p>
<font color="blue">像这种经典题如果是第一次见，搞懂然后记住就完了</font>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>{</span></span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">}t[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;<span class="comment">//第1步</span></span><br><span class="line">	<span class="built_in">dfs</span>(t[x].l);<span class="comment">//第2步</span></span><br><span class="line">	<span class="built_in">dfs</span>(t[x].r);<span class="comment">//第3步</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;t[i].l&gt;&gt;t[i].r;<span class="comment">//依次读入左右节点</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>之后在学数据结构的时候还有中序遍历、后序遍历，实现思路差不多</p>
<h2 id="K-迷宫（一）"><a href="#K-迷宫（一）" class="headerlink" title="K - 迷宫（一）"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/K">K - 迷宫（一）</a></h2><p>学会用数组表示方向，不一定要二维数组，两个一维的也行，甚至可以用循环表示</p>
<font color="blue">像这种经典题如果是第一次见，搞懂然后记住就完了</font>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {{<span class="number">-1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">-1</span>}};<span class="comment">//定义一个二维数组存方向，比如说(x-1,y+0)就是向上一个单位，使用方便</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>&lt;=x&amp;&amp;x&lt;n&amp;&amp;<span class="number">0</span>&lt;=y&amp;&amp;y&lt;m;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (mp[x][y]==<span class="string">'T'</span>){<span class="comment">//结束标志</span></span><br><span class="line">        f=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">in</span>(x,y)||mp[x][y]==<span class="string">'*'</span>||vis[x][y]){</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//看看有没有越界，撞墙，走过</span></span><br><span class="line">    }</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;<span class="comment">//dfs前做好标记，不能再走以前的路，所以不用再消除标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++){</span><br><span class="line">        <span class="keyword">int</span> tx=x+dir[i][<span class="number">0</span>];<span class="comment">//移动坐标</span></span><br><span class="line">        <span class="keyword">int</span> ty=y+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(tx,ty);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">           <span class="keyword">if</span>(mp[i][j]==<span class="string">'S'</span>){</span><br><span class="line">               x=i;<span class="comment">//先找到开始搜索的点</span></span><br><span class="line">               y=j;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(f){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="L-马走日"><a href="#L-马走日" class="headerlink" title="L - 马走日"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/L">L - 马走日</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">21</span>][<span class="number">22</span>],n,m,t;</span><br><span class="line"><span class="keyword">int</span> xx[<span class="number">10</span>]={<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>};<span class="comment">//用两个数组表示方向，也就是坐标变化</span></span><br><span class="line"><span class="keyword">int</span> yy[<span class="number">10</span>]={<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>};</span><br><span class="line"><span class="keyword">int</span> x,y,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">bool</span> p=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){<span class="comment">//判断是不是走过了所有点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==<span class="number">0</span>){</span><br><span class="line">                p=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">true</span>){</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">7</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> l=a+xx[i];</span><br><span class="line">        <span class="keyword">int</span> k=b+yy[i];</span><br><span class="line">        <span class="keyword">if</span>(f[l][k]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>&amp;&amp;l&lt;=n&amp;&amp;k&gt;<span class="number">0</span>&amp;&amp;k&lt;=m){ </span><br><span class="line">            f[l][k]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(l,k);</span><br><span class="line">            f[l][k]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;x,&amp;y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="M-八皇后问题"><a href="#M-八皇后问题" class="headerlink" title="M - 八皇后问题"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/M">M - 八皇后问题</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> tmp, ans;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> chess[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">no</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{<span class="comment">//判断两个皇后的坐标是否冲突</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) {</span><br><span class="line">		<span class="keyword">if</span> (x[i] == c || <span class="built_in">abs</span>(r - i) == <span class="built_in">abs</span>(c - x[i])) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (k == n) { </span><br><span class="line">	ans = <span class="built_in">max</span>(ans, tmp);<span class="comment">//找所有情况的八皇后的最大权值和</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">no</span>(k, i)) {</span><br><span class="line">			x[k] = i;<span class="comment">//dfs前做好标记</span></span><br><span class="line">			tmp += chess[k][i];</span><br><span class="line">			<span class="built_in">queen</span>(k + <span class="number">1</span>);</span><br><span class="line">			x[k] = <span class="number">0</span>;<span class="comment">//dfs后删除标记</span></span><br><span class="line">			tmp -= chess[k][i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--) {</span><br><span class="line">		tmp = ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;chess[i][j]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">queen</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="N-选数"><a href="#N-选数" class="headerlink" title="N - 选数"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/N">N - 选数</a></h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans,n,k,a[<span class="number">50</span>],i;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(a);i++)</span><br><span class="line">    <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(num==k){<span class="comment">//输入的k个数之和是素数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(sum))</span><br><span class="line">		++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">dfs</span>(num+<span class="number">1</span>,i+<span class="number">1</span>,sum+a[i]);<span class="comment">//向下一个数搜索</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="O-打开灯泡-Switch-the-Lamp-On"><a href="#O-打开灯泡-Switch-the-Lamp-On" class="headerlink" title="O - 打开灯泡 Switch the Lamp On"></a><a href="https://vjudge.csgrandeur.cn/contest/476110#problem/O">O - 打开灯泡 Switch the Lamp On</a></h2><p>想搞懂的自行了解c++<a href="https://blog.csdn.net/jay_zzs/article/details/106534034#:~:text=%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%88deque%EF%BC%89%20%E6%98%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%98%E5%BD%A2%EF%BC%8C%20%E4%B8%80%E8%88%AC%E9%98%9F%E5%88%97%E5%8F%AA%E8%83%BD%E5%9C%A8%E9%98%9F%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88push%EF%BC%89%EF%BC%8C%E5%9C%A8%E9%98%9F%E9%A6%96%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88pop%EF%BC%89%20%EF%BC%8C%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%20%E5%88%99%20%E5%90%8C%E6%97%B6%E5%9C%A8%E9%98%9F%E9%A6%96%E6%88%96%E8%80%85%E9%98%9F%E5%B0%BE%E6%89%A7%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B7%A5%E4%BD%9C,%E3%80%82%20C%2B%2B%20%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%20%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%20%3Cdeque%3E%20%E3%80%82">双端队列（deque）</a>的基本操作</p>
<p>搬运的题解：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dxy1[<span class="number">4</span>][<span class="number">2</span>]= {{<span class="number">1</span>,<span class="number">1</span>},{<span class="number">-1</span>,<span class="number">-1</span>},{<span class="number">1</span>,<span class="number">-1</span>},{<span class="number">-1</span>,<span class="number">1</span>}},dxy2[<span class="number">4</span>][<span class="number">2</span>]= {{<span class="number">1</span>,<span class="number">1</span>},{<span class="number">0</span>,<span class="number">0</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>}};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> t,n,m,ans=<span class="number">1e8</span>,dis[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line">deque&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;=m;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    q.<span class="built_in">push_front</span>(node {<span class="number">0</span>,<span class="number">0</span>});</span><br><span class="line">    dis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        node now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="built_in">fir</span>(i,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> tx=now.x+dxy1[i][<span class="number">0</span>],t1=now.x+dxy2[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ty=now.y+dxy1[i][<span class="number">1</span>],t2=now.y+dxy2[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> tt=(s[t1][t2] != (i&lt;=<span class="number">1</span>? <span class="string">'\\'</span>:<span class="string">'/'</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(tx,ty) &amp;&amp; dis[tx][ty]&gt;dis[now.x][now.y]+tt)</span><br><span class="line">            {</span><br><span class="line">                dis[tx][ty]=dis[now.x][now.y]+tt;</span><br><span class="line">                <span class="keyword">if</span>(tt)</span><br><span class="line">                    q.<span class="built_in">push_back</span>(node {tx,ty});</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.<span class="built_in">push_front</span>(node {tx,ty});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">fir</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">fir</span>(j,<span class="number">1</span>,m)</span><br><span class="line">        cin&gt;&gt;s[i][j];</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(dis[n][m]&lt;<span class="number">1e8</span>)</span><br><span class="line">            cout&lt;&lt;dis[n][m]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">"NO SOLUTION"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可算肝完了。。。</p>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假冬训营数学专题题解</title>
    <url>/2022/01/17/28/</url>
    <content><![CDATA[<h1 id="第22组数学专题题解"><a href="#第22组数学专题题解" class="headerlink" title="第22组数学专题题解"></a>第22组数学专题题解</h1><h2 id="A-A-B-Mod-C"><a href="#A-A-B-Mod-C" class="headerlink" title="A - A^B Mod C"></a>A - A^B Mod C</h2><p><a href="https://vjudge.csgrandeur.cn/contest/476638#problem/">传送门</a></p>
<p>思路：快速幂</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qm</span><span class="params">(ll a,ll b,ll mod)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    a%=mod;<span class="comment">//a不能太大 </span></span><br><span class="line">    <span class="keyword">while</span>(b){</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//如果b为奇数</span></span><br><span class="line">            res=(res*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算每轮b除二 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ll a,b,mod,res;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</span><br><span class="line">	res=<span class="built_in">qm</span>(a,b,mod);</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="B-逆元"><a href="#B-逆元" class="headerlink" title="B - 逆元"></a>B - 逆元</h2><p>思路：输出前(p-1)个数的逆元，但用常规方法会超时，但我们发现前(p-1)个数的逆元中，1~p-1各出现了一遍，于是<strong>等差数列</strong>求和得出了答案，当然<strong>i和p不互质就不存在逆元</strong>，只要<strong>p是素数</strong>就能和前面每一个数互质</p>
<p>要观察规律也得是知道怎么求一个数的逆元，下面我介绍三种方法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>:扩展欧几里得算法(<span class="built_in">o</span>(logmod),适用于所有模)</span><br><span class="line"> <span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	}</span><br><span class="line">	ll ret=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> mod)</span></span>{</span><br><span class="line">	ll x,y;</span><br><span class="line">	ll d=<span class="built_in">exgcd</span>(a,mod,x,y);</span><br><span class="line">	<span class="keyword">return</span> d==<span class="number">1</span>?(x%mod+mod)%mod:<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">——————————————————————————————我是一条可爱的分割线———————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>:费马小定理/欧拉定理(<span class="built_in">o</span>(logmod),就是求a^mod<span class="number">-2</span>,只适用于mod为素数)</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll a,ll p,ll mod)</span></span>{</span><br><span class="line">	ll t=<span class="number">1</span>,tt=a%mod;</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(p&amp;<span class="number">1</span>)t=t*tt%mod;</span><br><span class="line">		tt=tt*tt%mod;</span><br><span class="line">		p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">qkpow</span>(a,mod<span class="number">-2</span>,mod);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">——————————————————————————————我是一条可爱的分割线———————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>:递归求逆元(<span class="built_in">o</span>(logmod),思路和线性求逆元差不多,记住公式就完了，同样只适用于mod为素数)</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(m-m/a)*<span class="built_in">inv</span>(m%a,m)%m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">——————————————————————————————我是一条可爱的分割线———————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll a,ret;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a;i++){</span><br><span class="line">    		ret=<span class="built_in">inv</span>(i,a);</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"%lld "</span>,ret);</span><br><span class="line">		}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>题解：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(ll x)</span></span>{<span class="comment">//p为1时没请求，这里不需要考虑1</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll p;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;p){</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isprime</span>(p)){</span><br><span class="line">            cout&lt;&lt;<span class="string">"AKCniubi"</span>&lt;&lt;endl;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            cout&lt;&lt;(p<span class="number">-1</span>)*p/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="C-判决素数个数"><a href="#C-判决素数个数" class="headerlink" title="C - 判决素数个数"></a>C - 判决素数个数</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++){</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a,b,i,t,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b){<span class="comment">//题目并没有说a和b的大小关系</span></span><br><span class="line">		t=a;</span><br><span class="line">		a=b;</span><br><span class="line">		b=t;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(i=a;i&lt;=b;i++){</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isprime</span>(i)){</span><br><span class="line">			sum++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="D-矩阵乘法"><a href="#D-矩阵乘法" class="headerlink" title="D - 矩阵乘法"></a>D - 矩阵乘法</h2><p>虽然咱新生还没开线性代数，但这道题咱们已经遇到不止一次了</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">110</span>][<span class="number">110</span>],b[<span class="number">110</span>][<span class="number">110</span>],c[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">int</span> m,p,n;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;p,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;p;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//核心</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">            c[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;p;k++){</span><br><span class="line">                c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,c[i][j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="E-Bash游戏"><a href="#E-Bash游戏" class="headerlink" title="E - Bash游戏"></a>E - Bash游戏</h2><p>思路：博弈论，还剩(k+1)个石子时，先手怎么拿都是输</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t,n,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">if</span>(n%(k+<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="F-取石子游戏"><a href="#F-取石子游戏" class="headerlink" title="F - 取石子游戏"></a>F - 取石子游戏</h2><p>思路：<a href="https://blog.csdn.net/qq_41311604/article/details/79980882">威佐夫博奕</a>（讲的可清楚）</p>
<p>先手必输局势(a,b)近似满足(b-a)*1.618=a，因此只需判断两堆石子差值是否满足公式</p>
<p>floor是向下取整，如floor(3.9)=3，0.618是黄金比例，即(sqrt(5)-1.0)/2.0</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b,k,t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF){</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b){</span><br><span class="line">            t=b;</span><br><span class="line">            b=a;</span><br><span class="line">            a=t;</span><br><span class="line">        }</span><br><span class="line">        k=b-a;</span><br><span class="line">        t=(floor)(k*(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2.0</span>);<span class="comment">//核心</span></span><br><span class="line">        <span class="keyword">if</span>(t==a)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="G-Matches-Game"><a href="#G-Matches-Game" class="headerlink" title="G - Matches Game"></a>G - Matches Game</h2><p>思路：<a href="https://blog.csdn.net/cuijy/article/details/23692469">尼姆博弈</a></p>
<p>取每一堆中火柴的情况可分为四种：</p>
<p>（1）如果轮到某人取火柴的时候，火柴已经没有了，那么此人输，设为P-格局</p>
<p>（2）如果轮到某人取火柴的时候，他能够取完火柴，那么此人赢，设为N-格局</p>
<p>（3）如果轮到某人取火柴的时候，他能够将当前格局转化为某个P格局，那么此格局为N-格局</p>
<p>（4）如果轮到某人取火柴的时候，他不能将当前格局转化为某个P格局，那么此格局为P-格局</p>
<p>有这样一个定理：</p>
<p>一个格局记为（x1,x2,…,xn)，且次序无关，此格局为 P-格局 当且仅当 x1^x2^…^xn = 0</p>
<p>其中^是按位异或运算，即二进制中两个位相同为0，相异为1，我们只用判断最终状态</p>
<p>因此不断异或，如果结果不为0，则先手胜</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,ret;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF){</span><br><span class="line">		ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			ret=ret^a[i];<span class="comment">//核心</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="H-互质数的个数（一）"><a href="#H-互质数的个数（一）" class="headerlink" title="H - 互质数的个数（一）"></a>H - 互质数的个数（一）</h2><p>思路：<a href="https://blog.csdn.net/liuzibujian/article/details/81086324">欧拉函数</a></p>
<p>pi是x分解成的质因数，如20=2 <em> 2 </em> 5，φ(20)=20*(1-1/2)(1-1/5)=8</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">oula</span><span class="params">(ll n)</span></span>{</span><br><span class="line">    ll rea=n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>){</span><br><span class="line">            rea=rea-rea/i;<span class="comment">//遇到质因数就乘(1-1/pi)</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            n/=i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>);<span class="comment">//将重复的质因数筛去</span></span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">    rea=rea-rea/n;<span class="comment">//对1特殊处理</span></span><br><span class="line">    <span class="keyword">return</span> rea;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll t,ret;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--){</span><br><span class="line">        ll v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;v);</span><br><span class="line">        ret=<span class="built_in">oula</span>(v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ret);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="I-Sumdiv"><a href="#I-Sumdiv" class="headerlink" title="I - Sumdiv"></a>I - Sumdiv</h2><p>思路：<a href="https://blog.csdn.net/chabeizip/article/details/111568047">逆元+快速幂+约数和定理</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll a,b,m;</span><br><span class="line">ll prime[<span class="number">500000</span>],c[<span class="number">500000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(ll n)</span></span>{</span><br><span class="line">	<span class="keyword">for</span> (ll i=<span class="number">2</span>;i&lt;=n/i;i++){</span><br><span class="line">		<span class="keyword">if</span> (n % i==<span class="number">0</span>){</span><br><span class="line">			prime[++m]=i;</span><br><span class="line">			<span class="keyword">while</span>(n % i==<span class="number">0</span>){</span><br><span class="line">				n/=i;</span><br><span class="line">				c[m]++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (n&gt;<span class="number">1</span>){</span><br><span class="line">		prime[++m]=n;</span><br><span class="line">		c[m]=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a,ll b,ll p)</span></span>{</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b){</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>){</span><br><span class="line">			res=res*a%p;</span><br><span class="line">		}</span><br><span class="line">		a=a*a%p;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">divide</span>(a);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">		<span class="keyword">if</span>((prime[i]<span class="number">-1</span>)%<span class="number">9901</span>==<span class="number">0</span>){</span><br><span class="line">			ans=(b%<span class="number">9901</span>*c[i]%<span class="number">9901</span>+<span class="number">1</span>)*ans%<span class="number">9901</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		ans=(<span class="built_in">pow</span>(prime[i],b*c[i]+<span class="number">1</span>,<span class="number">9901</span>)<span class="number">-1</span>+<span class="number">9901</span>)%<span class="number">9901</span>*ans%<span class="number">9901</span>;</span><br><span class="line">		ll y=<span class="built_in">pow</span>(prime[i]<span class="number">-1</span>,<span class="number">9901</span><span class="number">-2</span>,<span class="number">9901</span>);</span><br><span class="line">		ans*=y;</span><br><span class="line">		ans%=<span class="number">9901</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="J-The-Lottery"><a href="#J-The-Lottery" class="headerlink" title="J - The Lottery"></a>J - The Lottery</h2><p>思路：容斥原理</p>
<p>我一开始想用素数筛，没看到2^31，数组开大直接编译错误</p>
<p>搬运的题解：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = {<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="function">LL <span class="title">GCD</span><span class="params">(LL a,LL b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">GCD</span>(b,a%b);</span><br><span class="line">}</span><br><span class="line"><span class="function">LL <span class="title">LCM</span><span class="params">(LL a,LL b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a/<span class="built_in">GCD</span>(a,b)*b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LL n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)) {</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">0</span>; i&lt;m; i++){</span><br><span class="line">            LL val;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;val);</span><br><span class="line">            <span class="keyword">if</span>(val&gt;<span class="number">0</span>&amp;&amp;val&lt;n)</span><br><span class="line">                a[tot++]=val;</span><br><span class="line">        }</span><br><span class="line">        LL sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;tot); i++) {</span><br><span class="line">            LL lcm=<span class="number">1</span>;</span><br><span class="line">            LL cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(LL j=<span class="number">0</span>; j&lt;tot; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) {</span><br><span class="line">                    lcm=<span class="built_in">LCM</span>(lcm,a[j]);</span><br><span class="line">                    cnt++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(cnt!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">                    sum+=(n)/lcm;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sum-=(n)/lcm;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,n-sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="K-组合数问题"><a href="#K-组合数问题" class="headerlink" title="K - 组合数问题"></a>K - 组合数问题</h2><p>思路：杨辉三角与组合数的关系</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2100</span>][<span class="number">2100</span>],f[<span class="number">2100</span>][<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++){</span><br><span class="line">        	c[i][i]=<span class="number">1</span>;</span><br><span class="line">			c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">                c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2000</span>;j++){</span><br><span class="line">                f[i][j]=f[i][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j]-f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(c[i][j]==<span class="number">0</span>&amp;&amp;j&lt;=i)</span><br><span class="line">                f[i][j]++;</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">while</span>(t--){</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[n][m]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="L-同余方程"><a href="#L-同余方程" class="headerlink" title="L - 同余方程"></a>L - 同余方程</h2><p>思路：扩展欧几里得</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,q;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>){<span class="comment">//到达边界 </span></span><br><span class="line">		x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">exgcd</span>(b,a%b);<span class="comment">//递归调用倒回去求最小解 </span></span><br><span class="line">		<span class="keyword">int</span> k=x;</span><br><span class="line">		x=y;</span><br><span class="line">		y=k-(a/b)*y;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;q);  </span><br><span class="line">	<span class="built_in">exgcd</span>(a,q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,(x+q)%q);<span class="comment">//+q以防x为负数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（2）</title>
    <url>/2022/01/24/29/</url>
    <content><![CDATA[<h1 id="STL-初步"><a href="#STL-初步" class="headerlink" title="STL 初步"></a>STL 初步</h1><h2 id="sort用法"><a href="#sort用法" class="headerlink" title="sort用法"></a>sort用法</h2><p>sort排序区间为下标范围为<strong>[n1,n2)</strong>的元素</p>
<p>从小到大排序：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(数组名+n1,数组名+n2);</span><br></pre></td></tr></tbody></table></figure>
<p>从大到小排序：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(数组名+n1,数组名+n2,greater&lt;type&gt;());</span><br></pre></td></tr></tbody></table></figure>
<p>自定义排序规则：</p>
<p>sort函数的第三个参数可以是<strong>函数对象</strong>也可以是<strong>函数指针</strong>；</p>
<p>1.cmp</p>
<p>如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">		<span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(stu a,stu b)</span></span>{</span><br><span class="line">		<span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">}</span><br><span class="line">	<span class="built_in">sort</span>(a,a+len;cmp);</span><br></pre></td></tr></tbody></table></figure>
<p>2.重载</p>
<p>如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span>{</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( <span class="keyword">const</span> T &amp; name1,<span class="keyword">const</span> T &amp; name2)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> name1 &lt; name2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rule</span> {</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Student &amp; s1,<span class="keyword">const</span> Student &amp; s2)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">	<span class="built_in">sort</span>(a,a+len;<span class="built_in">rule</span>());</span><br></pre></td></tr></tbody></table></figure>
<h2 id="stl里的二分查找算法"><a href="#stl里的二分查找算法" class="headerlink" title="stl里的二分查找算法"></a>stl里的二分查找算法</h2><p>二分查找(一种写法)：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">x</span> <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span>{</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10000</span>];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">}p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ef</span><span class="params">(List p,<span class="keyword">int</span> find)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> left,right,mid,no=<span class="number">-1</span>;</span><br><span class="line">	left=<span class="number">1</span>;</span><br><span class="line">	right=p.len;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right){</span><br><span class="line">		mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(find&lt;p.a[mid])</span><br><span class="line">		right=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(find&gt;p.a[mid])</span><br><span class="line">		left=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> no;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> num,find;</span><br><span class="line">	List p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p.len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p.len;i++){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p.a[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;find);</span><br><span class="line">	num=<span class="built_in">ef</span>(p,find);</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">-1</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Not found!"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,p.a[num]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>stlL提供在排好序的数组上进行二分查找的算法，查找区间为下标范围为[n1,n2)的元素</p>
<p>包括binary_search，lower_bound和upper_bound</p>
<p><font color="red">注意</font>：这里查找的规则是依据sort排序的规则而定的，所以不一定是值相等就找到</p>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(数组名+n1，数组名+n2,值,(排序规则)); </span><br></pre></td></tr></tbody></table></figure>
<h3 id="用upper-bound二分查找上界"><a href="#用upper-bound二分查找上界" class="headerlink" title="用upper_bound二分查找上界"></a>用upper_bound二分查找上界</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">type * <span class="title">upper_bound</span><span class="params">(数组名+n1,数组名+n2,值,(排序规则))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>返回一个指针 type * p，表示在值后面的第一个相邻元素;</p>
<h3 id="用lower-bound二分查找下界"><a href="#用lower-bound二分查找下界" class="headerlink" title="用lower_bound二分查找下界"></a>用lower_bound二分查找下界</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">type * <span class="title">lower_bound</span><span class="params">(数组名+n1,数组名+n2,(排序规则))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>也返回一个指针 type* p (p可换），表示在值前面的第一个相邻元素；</p>
<p>应用举例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span> {</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span> &amp; a1,<span class="keyword">const</span> <span class="keyword">int</span> &amp; a2)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> a1%<span class="number">10</span> &lt; a2%<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;++i) {</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">","</span> ;</span><br><span class="line">}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 7 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[NUM] = { <span class="number">12</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">98</span>,<span class="number">21</span>,<span class="number">7</span>};</span><br><span class="line">	<span class="built_in">sort</span>(a,a+NUM);</span><br><span class="line">	<span class="built_in">Print</span>(a,NUM); <span class="comment">// =&gt; 3,5,5,7,12,21,98,</span></span><br><span class="line">	<span class="keyword">int</span> * p = <span class="built_in">lower_bound</span>(a,a+NUM,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; <span class="string">","</span> &lt;&lt; p-a &lt;&lt; endl; <span class="comment">//=&gt; 5,1</span></span><br><span class="line">	p = <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//=&gt;7</span></span><br><span class="line">	cout &lt;&lt; * <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">13</span>) &lt;&lt; endl; <span class="comment">//=&gt;21</span></span><br><span class="line">    <span class="built_in">sort</span>(a,a+NUM,<span class="built_in">Rule</span>());</span><br><span class="line">	<span class="built_in">Print</span>(a,NUM); <span class="comment">//=&gt;21,12,3,5,5,7,98,</span></span><br><span class="line">	cout &lt;&lt; * <span class="built_in">lower_bound</span>(a,a+NUM,<span class="number">16</span>,<span class="built_in">Rule</span>()) &lt;&lt; endl; <span class="comment">// =&gt; 7</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">lower_bound</span>(a,a+NUM,<span class="number">25</span>,<span class="built_in">Rule</span>()) - a&lt;&lt; endl; <span class="comment">// =&gt; 3</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">18</span>,<span class="built_in">Rule</span>()) - a &lt;&lt; endl; <span class="comment">// =&gt; 7</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">18</span>,<span class="built_in">Rule</span>()) == a+NUM)</span><br><span class="line">	cout &lt;&lt; <span class="string">"not found"</span> &lt;&lt; endl; <span class="comment">//=&gt; not found</span></span><br><span class="line">	cout &lt;&lt; * <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">5</span>,<span class="built_in">Rule</span>()) &lt;&lt; endl; <span class="comment">// =&gt;7</span></span><br><span class="line">	cout &lt;&lt; * <span class="built_in">upper_bound</span>(a,a+NUM,<span class="number">4</span>,<span class="built_in">Rule</span>()) &lt;&lt; endl; <span class="comment">// =&gt;5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="STL中的平衡二叉树数据结构"><a href="#STL中的平衡二叉树数据结构" class="headerlink" title="STL中的平衡二叉树数据结构"></a>STL中的平衡二叉树数据结构</h2><p>目的是使增加数据、删除数据、查找数据都能在 log(n)复杂度完成</p>
<p>用到下面四种“排序容器”：multiset,set,multimap,map；</p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset用法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">multiset&lt;T&gt; st; </span><br></pre></td></tr></tbody></table></figure>
<p>定义了一个multiset变量st，st里面可以存放T类型的数据，并且能自动排序(默认a&lt;b为true)。开始时st为空</p>
<p>可用 st.insert添加元素，st.find查找元素，st.erase删除元素，复杂度 都是 log(n)</p>
<p>举例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> <span class="comment">//使用multiset和set需要此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	multiset&lt;<span class="keyword">int</span>&gt; st; </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]={<span class="number">1</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">19</span>,<span class="number">8</span>,<span class="number">8</span> };</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">		st.<span class="built_in">insert</span>(a[i]); <span class="comment">//插入的是a [i]的复制品</span></span><br><span class="line">	multiset&lt;<span class="keyword">int</span>&gt;::iterator i; <span class="comment">//迭代器，近似于指针</span></span><br><span class="line">	<span class="keyword">for</span>(i = st.<span class="built_in">begin</span>(); i != st.<span class="built_in">end</span>(); ++i) </span><br><span class="line">		cout &lt;&lt; * i &lt;&lt; <span class="string">","</span>; </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">输出：<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">21</span></span><br><span class="line">    </span><br><span class="line">	i = st.<span class="built_in">find</span>(<span class="number">22</span>); <span class="comment">//查找22，返回值是迭代器</span></span><br><span class="line">	<span class="keyword">if</span>( i == st.<span class="built_in">end</span>()) <span class="comment">//找不到则返回值为 end()</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"not found"</span> &lt;&lt; endl;</span><br><span class="line">	st.<span class="built_in">insert</span>(<span class="number">22</span>); <span class="comment">//插入 22</span></span><br><span class="line">	i = st.<span class="built_in">find</span>(<span class="number">22</span>);</span><br><span class="line">	<span class="keyword">if</span>( i == st.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">"not found"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"found:"</span> &lt;&lt; *i &lt;&lt;endl;</span><br><span class="line">	<span class="comment">//找到则返回指向找到的元素的迭代器</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">not</span> found</span><br><span class="line">found:<span class="number">22</span></span><br><span class="line">    i = st.<span class="built_in">lower_bound</span>(<span class="number">13</span>);</span><br><span class="line">	<span class="comment">//返回最靠后的迭代器 it，使得[begin(),it)中的元素</span></span><br><span class="line">	<span class="comment">//都在 13 前面 ，复杂度 log(n)</span></span><br><span class="line">	cout &lt;&lt; * i &lt;&lt; endl;</span><br><span class="line">	i = st.<span class="built_in">upper_bound</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="comment">//返回最靠前的迭代器 it，使得[it,end())中的元素</span></span><br><span class="line">	<span class="comment">//都在 8 后面，复杂度 log(n)</span></span><br><span class="line">	cout &lt;&lt; * i &lt;&lt; endl;</span><br><span class="line">	st.<span class="built_in">erase</span>(i); <span class="comment">//删除迭代器 i 指向的元素，即12</span></span><br><span class="line">	<span class="keyword">for</span>(i = st.<span class="built_in">begin</span>(); i != st.<span class="built_in">end</span>(); ++i) </span><br><span class="line">		cout &lt;&lt; * i &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">22</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>multiset 上的迭代器</strong>:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">multiset&lt;T&gt;::iterator p; </span><br></pre></td></tr></tbody></table></figure>
<p>p是迭代器，相当于指针，可用于指向multiset中的元素。访问multiset中的元素要通过迭代器</p>
<p>与指针的不同：</p>
<p>multiset上的迭代器可 ++ ，—， 用 != 和 == 比较，不可比大小，不可加减整数，不可相减</p>
<p>st.begin() 返回值类型为 multiset::iterator,  是指向st中的头一个元素的迭代器</p>
<p>st.end() 返回值类型为 multiset::iterator,  是指向st中的最后一个元素后面的迭代器</p>
<p>对迭代器 ++ ,其就指向容器中下一个元素，— 则令其指向上一个元素</p>
<p>自定义排序规则的multiset 用法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">multiset&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt; &gt; st;<span class="comment">//排序规则为从大到小</span></span><br><span class="line">multiset&lt;<span class="keyword">int</span>,Rule1&gt; st;</span><br><span class="line">multiset&lt;Student,Rule1&gt;::iterator p;<span class="comment">//对应迭代器写法</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>学set前先了解一下pair模板的用法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pair&lt;T1,T2&gt;</span><br><span class="line">等价于：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">};</span><br><span class="line">例如：pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; a;</span><br><span class="line">等价于：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="keyword">int</span> first;</span><br><span class="line"><span class="keyword">double</span> second;</span><br><span class="line">} a;</span><br><span class="line">a.first = <span class="number">1</span>;</span><br><span class="line">a.second = <span class="number">93.93</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><font color="red">注意</font>：first和second不能更换</p>
<p>set和multiset的区别在于容器里不能有重复元素</p>
<p>这里的重复也是依据预先定义的规则才有意义</p>
<p>set插入元素可能不成功（重复）</p>
<p>set在插入时返回的result.second如果为零，表示因重复而无法插入</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>multimap容器里的元素，都是pair形式的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">multimap&lt;T1,T2&gt; mp</span><br><span class="line"><span class="comment">//即都是如下类型：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	T1 first; <span class="comment">//关键字</span></span><br><span class="line">	T2 second; <span class="comment">//值</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>multimap中的元素按照first排序，并可以按first进行查找，默认”a.first &lt; b.first” 为true</p>
<p>应用举例：</p>
<p>一个学生成绩录入和查询系统，接受以下两种输入:</p>
<p> Add name id score </p>
<p>Query score</p>
<p>name是个不超过16字符的字符串，中间没有空格，代表学生姓名。id 是个整数，代表学号。score是个整数，表示分数。学号不会重复，分数 和姓名都可能重复。 </p>
<p>两种输入交替出现。第一种输入表示要添加一个学生的信息，碰到这 种输入，就记下学生的姓名、id和分数。第二种输入表示要查询，碰到这 种输入，就输出已有记录中分数比score低的最高分获得者的姓名、学号 和分数。如果有多个学生都满足条件，就输出学号最大的那个学生的信 息。如果找不到满足条件的学生，则输出“Nobody” </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">Add Jack <span class="number">12</span> <span class="number">78</span></span><br><span class="line">Query <span class="number">78</span></span><br><span class="line">Query <span class="number">81</span></span><br><span class="line">Add Percy <span class="number">9</span> <span class="number">81</span></span><br><span class="line">Add Marry <span class="number">8</span> <span class="number">81</span></span><br><span class="line">Query <span class="number">82</span></span><br><span class="line">Add Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line">Query <span class="number">80</span></span><br><span class="line">Query <span class="number">81</span></span><br><span class="line">输出样例：</span><br><span class="line">Nobody</span><br><span class="line">Jack <span class="number">12</span> <span class="number">78</span></span><br><span class="line">Percy <span class="number">9</span> <span class="number">81</span></span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  		<span class="comment">//使用multimap和map需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> {</span></span><br><span class="line">		<span class="keyword">int</span> id;</span><br><span class="line">		<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">};</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">		<span class="keyword">int</span> score;</span><br><span class="line">		StudentInfo info; </span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;<span class="keyword">int</span>,StudentInfo&gt; MAP_STD;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MAP_STD mp;</span><br><span class="line">	Student st;</span><br><span class="line">	<span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span>( cin &gt;&gt; cmd ) {</span><br><span class="line">		<span class="keyword">if</span>( cmd[<span class="number">0</span>] == <span class="string">'A'</span>) {</span><br><span class="line">			cin &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score ;</span><br><span class="line">			mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(st.score,st.info ));</span><br><span class="line">		} <span class="comment">//make_pair生成一个 pair&lt;int,StudentInfo&gt;变量</span></span><br><span class="line">		  <span class="comment">//其first 等于 st.score, second 等于 st.info</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( cmd[<span class="number">0</span>] == <span class="string">'Q'</span> ){</span><br><span class="line">		<span class="keyword">int</span> score;</span><br><span class="line">		cin &gt;&gt; score;</span><br><span class="line">		MAP_STD::iterator p = mp.<span class="built_in">lower_bound</span> (score);</span><br><span class="line">		<span class="keyword">if</span>( p!= mp.<span class="built_in">begin</span>()) { </span><br><span class="line">			--p;</span><br><span class="line">			score = p-&gt;first; <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">			MAP_STD::iterator maxp = p; </span><br><span class="line">			<span class="keyword">int</span> maxId = p-&gt;second.id; </span><br><span class="line">			<span class="keyword">for</span>(; p != mp.<span class="built_in">begin</span>() &amp;&amp; p-&gt;first == score; --p) {</span><br><span class="line">			<span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">			<span class="keyword">if</span>( p-&gt;second.id &gt; maxId ) {</span><br><span class="line">				maxp = p;</span><br><span class="line">				maxId = p-&gt;second.id ;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>( p-&gt;first == score) { </span><br><span class="line">		<span class="comment">//如果上面循环是因为 p == mp.begin() 而终止，则p指向的元素还要处理</span></span><br><span class="line">			<span class="keyword">if</span>( p-&gt;second.id &gt; maxId ) {</span><br><span class="line">				maxp = p;</span><br><span class="line">				maxId = p-&gt;second.id ;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="string">" "</span> &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="string">" "</span> &lt;&lt; maxp-&gt;first &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//lower_bound的结果就是 begin，说明没人分数比查询分数低</span></span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">"Nobody"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>和multimap区别在于：</p>
<p>不能有关键字重复的元素</p>
<p>可以使用 [] ，下标为关键字，返回值为first和关键字相同的元素的second</p>
<p>当然插入元素也可能失败<br>[]的用法如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> map&lt;string,<span class="keyword">int</span>&gt; MP;</span><br><span class="line">......</span><br><span class="line">Student students[<span class="number">5</span>] = {{<span class="string">"Jack"</span>,<span class="number">89</span>},{<span class="string">"Tom"</span>,<span class="number">74</span>},{<span class="string">"Cindy"</span>,<span class="number">87</span>},{<span class="string">"Alysa"</span>,<span class="number">87</span>},{<span class="string">"Micheal"</span>,<span class="number">98</span>}};</span><br><span class="line">......</span><br><span class="line">cout &lt;&lt; mp[<span class="string">"Jack"</span>] &lt;&lt; endl; <span class="comment">// 输出 89</span></span><br><span class="line">mp[<span class="string">"Jack"</span>] = <span class="number">60</span>; <span class="comment">//修改名为"Jack"的元素的second</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>很实用的例子</strong>：</p>
<p>单词词频统计程序</p>
<p>输入<font color="red">大量</font>单词，每个单词，一行，不超过20字符，没有空格。 按出现次数从多到少输出这些单词及其出现次数 。出现次数相同的，字典序靠前的在前面</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"><span class="keyword">this</span></span><br><span class="line">is</span><br><span class="line">ok</span><br><span class="line"><span class="keyword">this</span></span><br><span class="line">plus</span><br><span class="line">that</span><br><span class="line">is</span><br><span class="line">plus</span><br><span class="line">plus</span><br><span class="line">输出样例：</span><br><span class="line">plus <span class="number">3</span></span><br><span class="line">is <span class="number">2</span></span><br><span class="line"><span class="keyword">this</span> <span class="number">2</span></span><br><span class="line">ok <span class="number">1</span></span><br><span class="line">that <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p> 首先你要知道，大量意味着常规的二分加排序的方法必然超时，而用自定义排序规则的set和方便存储的map就可以高效解决问题</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Word</span> {</span></span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	string wd;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span> {</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">( <span class="keyword">const</span> Word &amp; w1,<span class="keyword">const</span> Word &amp; w2)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>( w1.times != w2.times)</span><br><span class="line">		<span class="keyword">return</span> w1.times &gt; w2.times;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> w1.wd &lt; w2.wd;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string s;</span><br><span class="line">	set&lt;Word,Rule&gt; st;</span><br><span class="line">	map&lt;string,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">while</span>( cin &gt;&gt; s ) </span><br><span class="line">		++ mp[s] ;</span><br><span class="line">	<span class="keyword">for</span>( map&lt;string,<span class="keyword">int</span>&gt;::iterator i = mp.<span class="built_in">begin</span>(); </span><br><span class="line">		i != mp.<span class="built_in">end</span>(); ++i) {</span><br><span class="line">			Word tmp;</span><br><span class="line">			tmp.wd = i-&gt;first;</span><br><span class="line">			tmp.times = i-&gt;second;</span><br><span class="line">			st.<span class="built_in">insert</span>(tmp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(set&lt;Word,Rule&gt;::iterator i = st.<span class="built_in">begin</span>(); </span><br><span class="line">		i != st.<span class="built_in">end</span>(); ++i) </span><br><span class="line">		cout &lt;&lt; i-&gt;wd &lt;&lt; <span class="string">" "</span> &lt;&lt; i-&gt;times &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>旧题整理</title>
    <url>/2022/02/05/30/</url>
    <content><![CDATA[<h2 id="郑轻oj"><a href="#郑轻oj" class="headerlink" title="郑轻oj"></a>郑轻oj</h2><h3 id="1124-两个有序数组合并"><a href="#1124-两个有序数组合并" class="headerlink" title="1124: 两个有序数组合并"></a>1124: 两个有序数组合并</h3><p><strong>题目描述</strong></p>
<p>已知数组a中有m个按升序序排列的元素，数组b中有n个降序排列的元素，编程将a与b中的所有元素按降序存入数组c中。</p>
<p><strong>输入</strong></p>
<p>输入有两行，第一行首先是一个正整数m，然后是m个整数；第二行首先是一个正整数n，然后是n个整数，m, n均小于等于1000000。</p>
<p><strong>输出</strong></p>
<p>输出合并后的m+n个整数，数据之间用空格隔开，输出占一行。</p>
<p><strong>样例输入</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4 1 2 5 7</span><br><span class="line">3 6 4 2</span><br></pre></td></tr></tbody></table></figure>
<p><strong>样例输出</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">7 6 5 4 2 2 1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>],b[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[j]);</span><br><span class="line">  </span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c[m+n];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=b[j])</span><br><span class="line">            c[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[k++]=b[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m)</span><br><span class="line">        c[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n)</span><br><span class="line">        c[k++] = b[j++];</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;m+n<span class="number">-1</span>; k++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,c[k]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[m+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1127-矩阵乘积"><a href="#1127-矩阵乘积" class="headerlink" title="1127: 矩阵乘积"></a>1127: 矩阵乘积</h3><p><strong>题目描述</strong></p>
<p>计算两个矩阵A和B的乘积。</p>
<p><strong>输入</strong></p>
<p>第一行三个正整数m、p和n，0&lt;=m,n,p&lt;=10，表示矩阵A是m行p列，矩阵B是p行n列；<br>接下来的m行是矩阵A的内容，每行p个整数，用空格隔开；<br>最后的p行是矩阵B的内容，每行n个整数，用空格隔开。</p>
<p><strong>输出</strong></p>
<p>输出乘积矩阵：输出占m行，每行n个数据，以空格隔开。</p>
<p><strong>样例输入</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2 3 4</span><br><span class="line"></span><br><span class="line">1 0 1</span><br><span class="line">0 0 1</span><br><span class="line"></span><br><span class="line">1 1 1 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 1 0</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>][<span class="number">11</span>],b[<span class="number">11</span>][<span class="number">11</span>],c[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> m,p,n;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;p,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;p; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;p; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        {</span><br><span class="line">            c[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;p; k++)</span><br><span class="line">            {</span><br><span class="line">                c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i][j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,c[i][j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1143-1144-多种进制"><a href="#1143-1144-多种进制" class="headerlink" title="1143-1144: 多种进制"></a>1143-1144: 多种进制</h3><p>将10进制正整数n转换成k进制数字符串输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dToK</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;n!=<span class="number">0</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        str[i]=n%k;</span><br><span class="line">        n=n/k;</span><br><span class="line">        x++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i=x<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,str[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将k进制数字符串转换成10进制正整数n输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KToD</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    {</span><br><span class="line">        sum=sum*k+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1151-大整数加法"><a href="#1151-大整数加法" class="headerlink" title="1151: 大整数加法"></a>1151: 大整数加法</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> m[<span class="number">1022</span>],n[<span class="number">1022</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1022</span>];</span><br><span class="line"><span class="keyword">int</span> lres;</span><br><span class="line"><span class="keyword">int</span> lm,ln;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(c[lres] &gt;=<span class="number">10</span>)</span><br><span class="line">        c[++lres]++,c[lres<span class="number">-1</span>] %=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lres++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,m,n);</span><br><span class="line">        lm = <span class="built_in">strlen</span>(m)<span class="number">-1</span>;</span><br><span class="line">        ln = <span class="built_in">strlen</span>(n)<span class="number">-1</span>;</span><br><span class="line">        lres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lm&gt;=<span class="number">0</span>&amp;&amp;ln&gt;=<span class="number">0</span>)</span><br><span class="line">            c[lres] += m[lm--]-<span class="string">'0'</span> + n[ln--] - <span class="string">'0'</span>,update();</span><br><span class="line">        <span class="keyword">while</span>(lm&gt;=<span class="number">0</span>)</span><br><span class="line">            c[lres]+=m[lm--]-<span class="string">'0'</span>,update();</span><br><span class="line">        <span class="keyword">while</span>(ln&gt;=<span class="number">0</span>)</span><br><span class="line">            c[lres] += n[ln--]-<span class="string">'0'</span>,update();</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lres; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) f=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1152-二分搜索"><a href="#1152-二分搜索" class="headerlink" title="1152: 二分搜索"></a>1152: 二分搜索</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> x,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==a[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[mid])</span><br><span class="line">            <span class="keyword">return</span> BSearch(a,x,low,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BSearch(a,x,mid+<span class="number">1</span>,high);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1673-机智的字符"><a href="#1673-机智的字符" class="headerlink" title="1673: 机智的字符"></a><a href="http://acm.zzuli.edu.cn/problem.php?id=1673">1673: 机智的字符</a></h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m,n,idx=<span class="number">0</span>,i,j;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    {</span><br><span class="line">        cout&lt;&lt;<span class="string">"&gt;"</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++,idx++)</span><br><span class="line">        {</span><br><span class="line">            cout&lt;&lt;(<span class="keyword">char</span>)(<span class="string">'a'</span>+idx%<span class="number">26</span>);</span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;<span class="string">"&lt;"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2838-小豪的室友"><a href="#2838-小豪的室友" class="headerlink" title="2838: 小豪的室友"></a><a href="http://acm.zzuli.edu.cn/problem.php?id=2838">2838: 小豪的室友</a></h3><p>最终状态有两种： </p>
<p>要么 wbwbwbw…. </p>
<p>要么 bwbwbwb…. </p>
<p>所以我们枚举两种情况，对于任何一种情况，分别用 x 和 y 表示没有 放对位置的黑书和白书的数量。对于每种情况，我们都先找出最小 的 交换次数，即 min(x,y),剩下的我们直接从小豪那里拿书替代。 故每种情况最少的操作次数为 ： </p>
<blockquote>
<p>min(x,y)+[max(x,y)-min(x,y)]=max(x,y); </p>
</blockquote>
<p>则最终结果： </p>
<blockquote>
<p>ans=min(max(x1,y1),max(x2,y2));</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> y;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n, len;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S);</span><br><span class="line">	<span class="keyword">int</span> flag1, flag2;</span><br><span class="line">	<span class="keyword">int</span> sum1, sum2;</span><br><span class="line">	flag1 = flag2 = sum1 = sum2 = <span class="number">0</span>;</span><br><span class="line">	len = <span class="built_in">strlen</span>(S);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		<span class="keyword">if</span> (S[i] == <span class="string">'w'</span>) {</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>)flag1++;</span><br><span class="line">		<span class="keyword">else</span> flag2++;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) sum1++;</span><br><span class="line">		<span class="keyword">else</span> sum2++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">min</span>(<span class="built_in">max</span>(flag1, sum2), <span class="built_in">max</span>(sum1, flag2));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2859-高难度运算"><a href="#2859-高难度运算" class="headerlink" title="2859: 高难度运算"></a><a href="http://acm.zzuli.edu.cn/problem.php?id=2859">2859: 高难度运算</a></h3><p>有一个不错的位运算公式</p>
<blockquote>
<p>(a&amp;b)+(a|b)=a+b;</p>
</blockquote>
<p>然后就是根据序列和来推出原序列了</p>
<h3 id="2872-小T的操作序列"><a href="#2872-小T的操作序列" class="headerlink" title="2872: 小T的操作序列"></a><a href="http://acm.zzuli.edu.cn/problem.php?id=2872">2872: 小T的操作序列</a></h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;n, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">int</span> a = n &amp; (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (a)</span><br><span class="line">		{</span><br><span class="line">			n -= (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">			x += y; </span><br><span class="line">			<span class="keyword">int</span> b = n &amp; (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">			n += (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h2><p>待更新</p>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（1）</title>
    <url>/2022/02/05/31/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔记整理自mooc<a href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计</a></p>
<p>郭炜老师讲的还是很清楚的</p>
<h2 id="第一章：从-C-到C"><a href="#第一章：从-C-到C" class="headerlink" title="第一章：从 C 到C++"></a>第一章：从 C 到C++</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>类型名 &amp; 引用名 = 某变量名;</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n; </span><br></pre></td></tr></tbody></table></figure>
<p>r引用了n，r的类型是<strong>int &amp;</strong></p>
<p>之后对r的修改就是对n的修改，对n的修改就是对r的修改</p>
<p>定义引用时一定要将其初始化成引用某个<strong>变量</strong>，之后不会再引用其他变量</p>
<p>在C语言中，我们可以通过指针实现两个数交换</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = * a; * a = * b; * b = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(&amp; n1,&amp; n2) ; </span><br></pre></td></tr></tbody></table></figure>
<p>有了C++的引用以后，可以这样写</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = a; a = b; b = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">swap(n1,n2) ;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用作为函数的返回值</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">SetValue</span>() = <span class="number">40</span>;<span class="comment">//类似于指针指向n</span></span><br><span class="line">	cout &lt;&lt; n;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} <span class="comment">//输出：40</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>常引用</strong></p>
<p>定义引用时，前面加const关键字，即为“常引用”</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n; </span><br></pre></td></tr></tbody></table></figure>
<p> r 的类型是 const int &amp;</p>
<p>注意：不能通过常引用去修改其引用的内容</p>
<h3 id="“const”关键字的用法"><a href="#“const”关键字的用法" class="headerlink" title="“const”关键字的用法"></a>“const”关键字的用法</h3><p><strong>定义常量指针，不可通过常量指针修改其指向的内容，但可以修改指向</strong></p>
<p>意义：函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p><strong>用new 运算符实现动态内存分配</strong></p>
<p>第一种用法，分配一个变量:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> Type;</span><br></pre></td></tr></tbody></table></figure>
<p>T是任意<strong>类型名</strong>，P是类型为T<em> 的指针。 动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该 内存空间的<em>*起始地址</em></em>赋值给P，如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="keyword">int</span>; </span><br><span class="line">* pn = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>第二种用法,分配一个数组：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pn;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="keyword">int</span>[i * <span class="number">20</span>];</span><br><span class="line">pn[<span class="number">0</span>] = <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>用“new”动态分配的内存空间，一定要用 “delete”（delete指针）运算符进行释放</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">* p = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//只能释放一次</span></span><br><span class="line"><span class="comment">//对于数组：</span></span><br><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> [ ] p;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>可以减少一些很简单的函数过多调用造成的开销</p>
<p>如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>( a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> f1,<span class="keyword">double</span> f2)</span> </span>{ }</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2)</span> </span>{ }</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> n3)</span> </span>{ }</span><br><span class="line"><span class="built_in">Max</span>(<span class="number">3.4</span>,<span class="number">2.5</span>); <span class="comment">//调用 (1)</span></span><br><span class="line"><span class="built_in">Max</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">//调用 (2)</span></span><br><span class="line"><span class="built_in">Max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//调用 (3)</span></span><br><span class="line"><span class="built_in">Max</span>(<span class="number">3</span>,<span class="number">2.4</span>); <span class="comment">//error,二义性</span></span><br></pre></td></tr></tbody></table></figure>
<p>编译器会根据调用语句的中的实参的个数和类型判断应该调用哪个函数</p>
<h3 id="函数的缺省参数"><a href="#函数的缺省参数" class="headerlink" title="函数的缺省参数"></a>函数的缺省参数</h3><p>C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">int</span> x1, <span class="keyword">int</span> x2 = <span class="number">2</span>, <span class="keyword">int</span> x3 = <span class="number">3</span>)</span> </span></span><br><span class="line"><span class="function"></span>{ }</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span> ) ; <span class="comment">//等效于 func(10,2,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">8</span>) ; <span class="comment">//等效于 func(10,8,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>, , <span class="number">8</span>) ; <span class="comment">//不行,只能最右边的连续若干个参数缺省</span></span><br></pre></td></tr></tbody></table></figure>
<p>目的在于提高程序的可扩充性</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（2）</title>
    <url>/2022/02/08/32/</url>
    <content><![CDATA[<h2 id="第二章-类和对象基础"><a href="#第二章-类和对象基础" class="headerlink" title="第二章 类和对象基础"></a>第二章 类和对象基础</h2><h3 id="类成员的可访问范围"><a href="#类成员的可访问范围" class="headerlink" title="类成员的可访问范围"></a>类成员的可访问范围</h3><p>在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">– <span class="keyword">private</span>: 私有成员，只能在成员函数内访问</span><br><span class="line">– <span class="keyword">public</span> : 公有成员，可以在任何地方访问</span><br><span class="line">– <span class="keyword">protected</span>: 保护成员</span><br></pre></td></tr></tbody></table></figure>
<p>以上三种关键字出现的<strong>次数和先后次序</strong>都没有限制。</p>
<p><strong>定义一个类:</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span> {</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		私有属性和函数</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		公有属性和函数</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		保护属性和函数</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p>
<p><strong>注意</strong>：在类的成员函数以外的地方，只能够访问该类对象的<strong>公有成员</strong>。</p>
<p>“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。</p>
<p><strong>用struct定义类：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CEmployee</span> {</span> </span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">30</span>]; <span class="comment">//缺省即公有</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="keyword">int</span> salary;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> * name)</span></span>; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">(<span class="keyword">char</span> * name)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">averageSalary</span><span class="params">(CEmployee e1,CEmployee e2)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>和用”class”的唯一区别，就是未说明是公有还是私有的成员，就是公有</p>
<h3 id="成员函数的重载及参数缺省"><a href="#成员函数的重载及参数缺省" class="headerlink" title="成员函数的重载及参数缺省"></a>成员函数的重载及参数缺省</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> {</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">( <span class="keyword">int</span> x=<span class="number">0</span> , <span class="keyword">int</span> y = <span class="number">0</span> )</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">( <span class="keyword">int</span> val )</span> </span>{ x = val ;}</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }<span class="comment">//重载</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>成员函数可以重载,可以带缺省参数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">( <span class="keyword">int</span> val = <span class="number">0</span>)</span> </span>{ x = val; }</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">......</span><br><span class="line">A.<span class="built_in">valueX</span>();<span class="comment">//存在二义性，编译器无法判断调用哪个valueX</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数 (constructor)"></a>构造函数 (constructor)</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">double</span> real, imag;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">( <span class="keyword">double</span> r, <span class="keyword">double</span> i)</span></span>;</span><br><span class="line">}; <span class="comment">//编译器自动生成默认构造函数</span></span><br><span class="line">Complex c1; <span class="comment">//默认构造函数被调用</span></span><br></pre></td></tr></tbody></table></figure>
<p>成员函数的一种，<strong>名字与类名相同</strong>，可以有参数，不能有返回值(void也不行) </p>
<p><strong>作用</strong>是对对象进行初始化，如给成员变量<strong>赋初值</strong> </p>
<p>如果定义类时没写构造函数，则编译器生成一个<strong>默认的无参数的构造函数</strong>，默认构造函数无参数，不做任何操作，如果定义了构造函数，则编译器<strong>不生成</strong>默认的无参数的构造函数</p>
<p>对象生成时构造函数<strong>自动被调用</strong>，对象一旦生成，就再也不能在其上执行构造函数</p>
<p><strong>为什么需要：</strong></p>
<p>不必专门再写初始化函数，也不用担心忘记调用初始化函数</p>
<p>自己定义：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">double</span> real, imag;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Complex</span>( <span class="keyword">double</span> r, <span class="keyword">double</span> i = <span class="number">0</span>);</span><br><span class="line">}; </span><br><span class="line">		Complex::<span class="built_in">Complex</span>( <span class="keyword">double</span> r, <span class="keyword">double</span> i) </span><br><span class="line">{</span><br><span class="line">		real = r; imag = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Complex * pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>一个类可以有<strong>多个</strong>构造函数，类似<strong>重载</strong></p>
<h3 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">CSample array2[<span class="number">2</span>] = {<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">CSample array3[<span class="number">2</span>] = {<span class="number">3</span>};<span class="comment">//注意这里只对array3[0]初始化成3，array3[1]默认初始化成0</span></span><br></pre></td></tr></tbody></table></figure>
<p>还可以这样写：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>( <span class="keyword">int</span> n) { } 		<span class="comment">//(1)</span></span><br><span class="line">		<span class="built_in">Test</span>( <span class="keyword">int</span> n, <span class="keyword">int</span> m) { } <span class="comment">//(2) </span></span><br><span class="line">		<span class="built_in">Test</span>() { } 				<span class="comment">//(3)</span></span><br><span class="line">};</span><br><span class="line">Test array1[<span class="number">3</span>] = { <span class="number">1</span>, <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>) };</span><br><span class="line"><span class="comment">// 三个元素分别用(1),(2),(3)初始化</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="复制构造函数-copyconstructor"><a href="#复制构造函数-copyconstructor" class="headerlink" title="复制构造函数 (copyconstructor)"></a>复制构造函数 (copyconstructor)</h3><p>只有一个参数,即<strong>对同类对象的引用</strong>。</p>
<p>形如 <strong>X::X( X&amp; )或X::X(const X &amp;)</strong>, 后者能以常量对象作为参数</p>
<p>如果没有定义复制构造函数，那么编译器生成<strong>默认复制构造函数</strong>。默认的复制构造函数完成复制功能。如果定义的自己的复制构造函数，则默认的复制构造函数不存在。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="keyword">double</span> real,imag;</span><br><span class="line">	<span class="built_in">Complex</span>(){ }</span><br><span class="line">	<span class="built_in">Complex</span>( <span class="keyword">const</span> Complex &amp; c ) {</span><br><span class="line">		real = c.real;</span><br><span class="line">		imag = c.imag;</span><br><span class="line">		cout &lt;&lt; “Copy Constructor called”;</span><br><span class="line">	}</span><br><span class="line">}; </span><br><span class="line">Complex c1; <span class="comment">//调用缺省无参构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//调用缺省的复制构造函数,将 c2 初始化成和c1一样</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="复制构造函数起作用的三种情况"><a href="#复制构造函数起作用的三种情况" class="headerlink" title="复制构造函数起作用的三种情况"></a>复制构造函数起作用的三种情况</h4><h5 id="1-当用一个对象去初始化同类的另一个对象时"><a href="#1-当用一个对象去初始化同类的另一个对象时" class="headerlink" title="1)当用一个对象去初始化同类的另一个对象时"></a>1)当用一个对象去初始化同类的另一个对象时</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1; <span class="comment">//初始化语句，非赋值语句</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-如果某函数有一个参数是类-A-的对象，-那么该函数被调用时，类A的复制构造函数将被调用"><a href="#2-如果某函数有一个参数是类-A-的对象，-那么该函数被调用时，类A的复制构造函数将被调用" class="headerlink" title="2)如果某函数有一个参数是类 A 的对象， 那么该函数被调用时，类A的复制构造函数将被调用"></a>2)如果某函数有一个参数是类 A 的对象， 那么该函数被调用时，类A的复制构造函数将被调用</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() { };</span><br><span class="line">	<span class="built_in">A</span>( A &amp; a) { </span><br><span class="line">		cout &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>{ }</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	A a2;</span><br><span class="line">	<span class="built_in">Func</span>(a2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">输出结果: </span><br><span class="line">Copy constructor called</span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-如果函数的返回值是类A的对象时，则函数返回时，-A的复制构造函数被调用"><a href="#3-如果函数的返回值是类A的对象时，则函数返回时，-A的复制构造函数被调用" class="headerlink" title="3) 如果函数的返回值是类A的对象时，则函数返回时， A的复制构造函数被调用"></a>3) 如果函数的返回值是类A的对象时，则函数返回时， A的复制构造函数被调用</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> n) { v = n; };</span><br><span class="line">	<span class="built_in">A</span>( <span class="keyword">const</span> A &amp; a) { </span><br><span class="line">		v = a.v;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Copy constructor called"</span> &lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span> </span>{ </span><br><span class="line">	<span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>; </span><br><span class="line">	<span class="keyword">return</span> b; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{ </span><br><span class="line">	cout &lt;&lt; <span class="built_in">Func</span>().v &lt;&lt; endl; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line">输出结果：</span><br><span class="line">Copy constructor called</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：对象间赋值并不导致复制构造函数被调用,还有就是<strong>引用前加上const</strong>可以防止实参被误改</p>
<h3 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h3><p>定义转换构造函数的目的是<strong>实现类型的自动转换</strong>。</p>
<p>只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。</p>
<p>当需要的时候，编译系统会自动调用转换构造函数，<strong>建立一个无名的临时对象</strong>(或临时变量)。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="keyword">double</span> real, imag;</span><br><span class="line">		<span class="built_in">Complex</span>( <span class="keyword">int</span> i) {<span class="comment">//类型转换构造函数</span></span><br><span class="line">			cout &lt;&lt; <span class="string">"IntConstructor called"</span> &lt;&lt; endl;</span><br><span class="line">			real = i; imag = <span class="number">0</span>; </span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">Complex</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> i) {real = r; imag = i; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">	Complex c2 = <span class="number">12</span>;</span><br><span class="line">	c1 = <span class="number">9</span>; <span class="comment">//9不是对象不能初始化，所以9被自动转换成一个临时Complex对象</span></span><br><span class="line">	cout &lt;&lt; c1.real &lt;&lt; <span class="string">","</span> &lt;&lt; c1.imag &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="析构函数-destructors"><a href="#析构函数-destructors" class="headerlink" title="析构函数 (destructors)"></a>析构函数 (destructors)</h3><p>名字<strong>与类名相同</strong>，在前面加‘~’ ，没有参数和返回值，一个类<strong>最多只能有一个析构函数</strong>。</p>
<p>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</p>
<p>如果定义类时没写析构函数，则编译器生成缺省析构函数。 缺省析构函数什么也不做。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>{</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">char</span> * p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">String</span> () {</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">	}</span><br><span class="line">	~ <span class="built_in">String</span> () ;</span><br><span class="line">};</span><br><span class="line">String ::~ <span class="built_in">String</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">delete</span> [] p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。</p>
<p>delete对象导致析构函数调用</p>
<p>析构函数在对象作为函数返回值返回后被调用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span> {</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CMyclass</span>() { cout &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line">	CMyclass obj;</span><br><span class="line">	<span class="function">CMyclass <span class="title">fun</span><span class="params">(CMyclass sobj )</span> </span>{ <span class="comment">//参数对象消亡也会导致析</span></span><br><span class="line"><span class="comment">//构函数被调用</span></span><br><span class="line">    <span class="keyword">return</span> sobj; <span class="comment">//函数调用返回时生成临时对象返回</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	obj = <span class="built_in">fun</span>(obj); <span class="comment">//函数调用的返回值（临时对象）被</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//用过后，该临时对象析构函数被调用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面有一个不错的例子可以检验一下你的学习成果✨</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> {</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Demo</span>(<span class="keyword">int</span> i) {</span><br><span class="line">		id = i;</span><br><span class="line">		cout &lt;&lt; <span class="string">"id="</span> &lt;&lt; id &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">	~<span class="built_in">Demo</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"id="</span> &lt;&lt; id &lt;&lt; <span class="string">" destructed"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function">Demo <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Demo <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Demo <span class="title">d3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"func"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Demo <span class="title">d4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	d4 = <span class="number">6</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"main"</span> &lt;&lt; endl;</span><br><span class="line">{ 	</span><br><span class="line">    <span class="function">Demo <span class="title">d5</span><span class="params">(<span class="number">5</span>)</span></span>; </span><br><span class="line">}</span><br><span class="line">	<span class="built_in">Func</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"main ends"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>看一看输出是不是和你想的一样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">id=<span class="number">1</span> constructed</span><br><span class="line">id=<span class="number">4</span> constructed</span><br><span class="line">id=<span class="number">6</span> constructed</span><br><span class="line">id=<span class="number">6</span> destructed</span><br><span class="line">main</span><br><span class="line">id=<span class="number">5</span> constructed</span><br><span class="line">id=<span class="number">5</span> destructed</span><br><span class="line">id=<span class="number">2</span> constructed</span><br><span class="line">id=<span class="number">3</span> constructed</span><br><span class="line">func</span><br><span class="line">id=<span class="number">3</span> destructed</span><br><span class="line">main ends</span><br><span class="line">id=<span class="number">6</span> destructed</span><br><span class="line">id=<span class="number">2</span> destructed</span><br><span class="line">id=<span class="number">1</span> destructed</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假冬训营递推专题题解</title>
    <url>/2022/02/09/33/</url>
    <content><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://vjudge.csgrandeur.cn/contest/479448">传送门</a></h2><p><strong>密码：202202060000</strong></p>
<h2 id="A-上台阶2"><a href="#A-上台阶2" class="headerlink" title="A - 上台阶2"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/A">A - 上台阶2</a></h2><p>分情况递归</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  dp[<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>]=<span class="number">1</span>,dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i){</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">5</span>)</span><br><span class="line">      dp[i]=(dp[i]+dp[i<span class="number">-1</span>]+dp[i<span class="number">-3</span>]+dp[i<span class="number">-5</span>])%mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">3</span>)</span><br><span class="line">      dp[i]=(dp[i]+dp[i<span class="number">-1</span>]+dp[i<span class="number">-3</span>])%mod;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="B-数字三角形"><a href="#B-数字三角形" class="headerlink" title="B - 数字三角形"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/B">B - 数字三角形</a></h2><p>二维数组向上递推，推到最后maxSum [ 1 ] [ 1 ]就是最大的和</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> D[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxSum[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i,j; </span><br><span class="line">	cin&gt;&gt;n; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++) </span><br><span class="line">			cin&gt;&gt;D[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		maxSum[n][i]=D[n][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i) </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j) </span><br><span class="line">			maxSum[i][j]=<span class="built_in">max</span>(maxSum[i+<span class="number">1</span>][j],maxSum[i+<span class="number">1</span>][j+<span class="number">1</span>])+D[i][j];</span><br><span class="line">	cout&lt;&lt;maxSum[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用指针进行空间优化：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 101</span></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> *maxSum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			cin &gt;&gt; D[i][j];</span><br><span class="line">	maxSum = D[n]; <span class="comment">//maxSum指向第n行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">			maxSum[j]=<span class="built_in">max</span>(maxSum[j],maxSum[j+<span class="number">1</span>])+D[i][j];</span><br><span class="line">	cout&lt;&lt;maxSum[<span class="number">1</span>]&lt;&lt;endl; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="C-矩阵取数问题"><a href="#C-矩阵取数问题" class="headerlink" title="C - 矩阵取数问题"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/C">C - 矩阵取数问题</a></h2><p>很经典的递推</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">		   cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)  </span><br><span class="line">       dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)  </span><br><span class="line">	   dp[<span class="number">0</span>][i]=<span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)                  </span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">	   	    dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+a[i][j]; </span><br><span class="line">	cout&lt;&lt;dp[N][N]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="D-背包问题"><a href="#D-背包问题" class="headerlink" title="D - 背包问题"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/D">D - 背包问题</a></h2><p>01背包，不会的可以去学一下，推荐<a href="https://www.icourse163.org/course/PKU-1001894005">郭炜老师的算法课</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">			<span class="keyword">if</span>(j&lt;w[i])<span class="comment">//装不下</span></span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);<span class="comment">//装得下就可以比较装与不装哪个价值大</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> f[n][m];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;<span class="built_in">fun</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="E-完全背包"><a href="#E-完全背包" class="headerlink" title="E - 完全背包"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/E">E - 完全背包</a></h2><p>和01背包不同之处在于每件物品可以无限取，把01背包公式里的<strong>f [ i - 1 ] [ j - w [ i ] ]</strong>改成<strong>f [ i ] [ j - w [ i ] ]</strong>就行了</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">10010</span>]; </span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">			<span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-w[i]]+v[i]);<span class="comment">//改成i就可以重复取当前的物品</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">		<span class="keyword">return</span> f[n][m];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;<span class="built_in">fun</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用一维数组进行空间优化：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++){</span><br><span class="line">			f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">		<span class="keyword">return</span> f[m];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	cout&lt;&lt;<span class="built_in">fun</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="F-背包问题-V2"><a href="#F-背包问题-V2" class="headerlink" title="F - 背包问题 V2"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/F">F - 背包问题 V2</a></h2><p>多重背包，介绍两种方法，首先三个循环下来肯定超时，所以我们可以尝试减少物品数量：</p>
<p>我们可以<a href="https://blog.csdn.net/seveny_/article/details/82230252">用二进制来化简</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">50050</span>];</span><br><span class="line"><span class="keyword">int</span> wi[<span class="number">10000</span>],p[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,w;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;w);</span><br><span class="line">    <span class="keyword">int</span> a,b,c,kp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;c;j*=<span class="number">2</span>){</span><br><span class="line">    		<span class="keyword">if</span> (c&gt;=j){</span><br><span class="line">				wi[kp]=a*j;</span><br><span class="line">				p[kp++]=b*j;</span><br><span class="line">				c-=j;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				wi[kp]=a*c;</span><br><span class="line">				p[kp++]=b*c;</span><br><span class="line">				c=<span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;kp;i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j=w;j&gt;=wi[i];j--)</span><br><span class="line">    	 dp[j]=<span class="built_in">max</span>(dp[j],dp[j-wi[i]]+p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还可以这样想：</p>
<p>如果一种物品的重量*数量&gt;背包容量，就可以当做完全背包来看待</p>
<p>如果小于，我们再用二进制分解，这是一个模板</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">50001</span>;</span><br><span class="line"><span class="keyword">int</span> dp[SIZE];</span><br><span class="line"><span class="keyword">int</span> volume[MAXN], value[MAXN], c[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, v;           <span class="comment">// 总物品数，背包容量</span></span><br><span class="line"><span class="comment">// 01背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnepark</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v ; j &gt;= vol; j--)</span><br><span class="line">    {</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - vol] + val);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Completepark</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = vol; j &lt;= v; j++)</span><br><span class="line">    {</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - vol] + val);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 多重背包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiplepark</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (vol * amount &gt;= v) {</span><br><span class="line">        <span class="built_in">Completepark</span>(val, vol);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount) {</span><br><span class="line">            <span class="built_in">ZeroOnepark</span>(k * val, k * vol);</span><br><span class="line">            amount -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">ZeroOnepark</span>(amount * val, amount * vol);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    	cin &gt;&gt; n &gt;&gt; v; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">            cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; c[i];<span class="comment">// 费用，价值，数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">Multiplepark</span>(value[i], volume[i], c[i]);</span><br><span class="line">        cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="G-最长上升子序列"><a href="#G-最长上升子序列" class="headerlink" title="G - 最长上升子序列"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/G">G - 最长上升子序列</a></h2><p>递推</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> maxLen[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i){</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">	maxLen[i]=<span class="number">1</span>;<span class="comment">//初始化边界为1</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">			maxLen[i]=<span class="built_in">max</span>(maxLen[i],maxLen[j]+<span class="number">1</span>);<span class="comment">//上升就比较加1的情况和原来的情况，大小是不确定的，你可以找数验证</span></span><br><span class="line">	cout&lt;&lt; *<span class="built_in">max_element</span>(maxLen+<span class="number">1</span>,maxLen+N+<span class="number">1</span>);<span class="comment">//输出数组中最大的元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="H-最长公共子序列Lcs"><a href="#H-最长公共子序列Lcs" class="headerlink" title="H - 最长公共子序列Lcs"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/H">H - 最长公共子序列Lcs</a></h2><p>这个题原本是一道O(mn)过不了的题，需要用bitset优化，有兴趣的可以<a href="https://loj.ac/p/6564">去看看</a>，推荐<a href="https://www.cnblogs.com/-Wallace-/p/bit-lcs.html">这个</a>教程</p>
<p>改题了之后就好多了，这个题可以用二维数组递推，也可以用滚动数组(这里不再赘述)</p>
<p>先推出递推公式，再想办法推出一个原序列，我这里给大家推一下公式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果i串和j串当前字符相等，那当前i，j 的状态就是没算上这个公共字符的i-1,j-1状态再加1</p>
<p>如果i串和j串当前字符不相等，我们要证明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br></pre></td></tr></tbody></table></figure>
<p>可以反证：</p>
<p>S1 [ i - 1] != s2 [ j - 1]时，MaxLen(S1,S2)不会比MaxLen(S1,S2j-1)和MaxLen(S1i-1,S2)两者之中任何一个小，也不会比两者都大。</p>
<p>MaxLen(S1,S2)不会比MaxLen(S1,S2j-1)和MaxLen(S1i-1,S2)两者之中任何一个小是很容易看出来的，因为MaxLen状态是递增的，下标大的状态不会小于下标小的状态。</p>
<p>后半句我们再反证一下：</p>
<p>也就是说，假设它比两者都大，那么对于MaxLen(S1,S2j-1)，S2j-1就算是最后一个公共字符了，否则MaxLen(S1,S2)就和MaxLen(S1,S2j-1)相等了；同理我们可以推出S1i-1也是最后一个公共字符，那么S1 [ i - 1]就和s2 [ j - 1]相等了，和前提S1 [ i - 1] != s2 [ j - 1]矛盾，至此得证。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> a[maxn],b[maxn],lcs[maxn];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> lena=<span class="built_in">strlen</span>(a),lenb=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=lena;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=lenb;j++){</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])</span><br><span class="line">			dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);<span class="comment">//比较难理解的地方</span></span><br><span class="line">        }</span><br><span class="line">    i=lena,j=lenb;</span><br><span class="line">    <span class="keyword">int</span> len=dp[lena][lenb];</span><br><span class="line">    lcs[len]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(dp[i][j]){<span class="comment">//倒推出一个最大公共子序列</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i][j]==dp[i<span class="number">-1</span>][j]) i--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j]==dp[i][j<span class="number">-1</span>]) j--;</span><br><span class="line">        <span class="keyword">else</span> lcs[--len]=a[i<span class="number">-1</span>],i--,j--;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,lcs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="I-石子合并"><a href="#I-石子合并" class="headerlink" title="I - 石子合并"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/I">I - 石子合并</a></h2><p>可以先去了解一下矩阵连乘，四边形优化</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N],f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++){</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++) </span><br><span class="line">	s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l + len - <span class="number">1</span> &lt;= <span class="number">2</span>*n;l++){</span><br><span class="line">            <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = l;k &lt; r;k++){</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">                g[l][r] = <span class="built_in">max</span>(g[l][r],g[l][k]+g[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res1 = <span class="number">1e9</span>,res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++){</span><br><span class="line">        res1 = <span class="built_in">min</span>(res1,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        res2 = <span class="built_in">max</span>(res2,g[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;res1&lt;&lt;endl&lt;&lt;res2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="J-循环数组最大子段和"><a href="#J-循环数组最大子段和" class="headerlink" title="J - 循环数组最大子段和"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/J">J - 循环数组最大子段和</a></h2><p>这个题思路比较巧妙</p>
<p>如果不循环，那么状态转移方程：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">　　dp[i]=dp[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　dp[i]=a[i];</span><br></pre></td></tr></tbody></table></figure>
<p>如果循环，可以认为不要中间一段最大负段和，要的是头部一段加尾部一段</p>
<p>求最大负段和，可以把数组所有值求个相反数，然后求最大正段和</p>
<p><strong>注意: 这里说的负段和不是连续的负数，别误解了</strong></p>
<p>最后，只需要比较头部一段加尾部一段的和与最大正段和的大小</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,a[<span class="number">50005</span>];</span><br><span class="line"><span class="function">ll <span class="title">maxsum</span><span class="params">(ll a[])</span></span>{<span class="comment">//求最大段和</span></span><br><span class="line">    ll sum=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) </span><br><span class="line">            sum=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;m)</span><br><span class="line">            m=sum;        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    }</span><br><span class="line">    ll ans=<span class="built_in">maxsum</span>(a);<span class="comment">//正向求不循环的最大段和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        a[i]=-a[i];</span><br><span class="line">    ll ans1=<span class="built_in">maxsum</span>(a);<span class="comment">//求序列最大的负段和的相反数</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(ans,ans1+sum)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="K-没有上司的舞会"><a href="#K-没有上司的舞会" class="headerlink" title="K - 没有上司的舞会"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/K">K - 没有上司的舞会</a></h2><p>树形dp,感兴趣的可以<a href="https://blog.csdn.net/weixin_43540515/article/details/102507640">了解一下</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">100010</span>][<span class="number">2</span>],happy[<span class="number">100010</span>],flag[<span class="number">100010</span>];</span><br><span class="line">vector &lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; son[<span class="number">100010</span>],link[<span class="number">100010</span>];</span><br><span class="line">queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"> dp[x][<span class="number">1</span>]=happy[x];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)</span><br><span class="line"> {</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> y=son[x][i];</span><br><span class="line">  <span class="built_in">f</span>(y);</span><br><span class="line">  dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]);</span><br><span class="line">  dp[x][<span class="number">1</span>]+=dp[y][<span class="number">0</span>];</span><br><span class="line"> }	</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> n,a,b;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cin&gt;&gt;happy[i];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"> {</span><br><span class="line"> 	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    link[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    link[b].<span class="built_in">push_back</span>(a);</span><br><span class="line"> }</span><br><span class="line"> q.<span class="built_in">push</span>(<span class="number">1</span>);flag[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line"> {</span><br><span class="line"> 	<span class="keyword">long</span> <span class="keyword">long</span> t=q.<span class="built_in">front</span>(),tmp;</span><br><span class="line"> 	q.<span class="built_in">pop</span>();</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;link[t].<span class="built_in">size</span>();i++)</span><br><span class="line"> 	 <span class="keyword">if</span>(!flag[link[t][i]])</span><br><span class="line"> 	 {</span><br><span class="line"> 	  	tmp=link[t][i];</span><br><span class="line"> 	  	q.<span class="built_in">push</span>(tmp);</span><br><span class="line"> 	  	flag[tmp]=<span class="number">1</span>;</span><br><span class="line"> 	  	son[t].<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	 }</span><br><span class="line"> }</span><br><span class="line"> <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line"> cout&lt;&lt;<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="L-滑雪"><a href="#L-滑雪" class="headerlink" title="L - 滑雪"></a><a href="https://vjudge.csgrandeur.cn/contest/479448#problem/L">L - 滑雪</a></h2><p>记忆化搜索</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> R,C,snow[<span class="number">105</span>][<span class="number">105</span>],sum;</span><br><span class="line"><span class="keyword">int</span> rmb[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//记住搜索过的点，避免无用的重复搜索，节省大量时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> len)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>||x&gt;R||y&gt;C)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rmb[x][y]!=<span class="number">0</span>){</span><br><span class="line">		sum=<span class="built_in">max</span>(sum,len+rmb[x][y]<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	sum=<span class="built_in">max</span>(sum,len);</span><br><span class="line">	<span class="keyword">if</span>(snow[x][y+<span class="number">1</span>]&lt;snow[x][y]) <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,len+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(snow[x+<span class="number">1</span>][y]&lt;snow[x][y]) <span class="built_in">dfs</span>(x+<span class="number">1</span>,y,len+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(snow[x][y<span class="number">-1</span>]&lt;snow[x][y]) <span class="built_in">dfs</span>(x,y<span class="number">-1</span>,len+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(snow[x<span class="number">-1</span>][y]&lt;snow[x][y]) <span class="built_in">dfs</span>(x<span class="number">-1</span>,y,len+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;R,&amp;C);</span><br><span class="line">	<span class="keyword">int</span> Max=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;++j){</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;snow[i][j]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;++j){</span><br><span class="line">			sum=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(i,j,<span class="number">1</span>);</span><br><span class="line">			rmb[i][j]=sum;</span><br><span class="line">			Max=<span class="built_in">max</span>(Max,sum);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,Max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（3）</title>
    <url>/2022/02/10/34/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于开学在即，竞赛也不远了，可我的算法却没学多少，所以我打算先整理STL</p>
<h2 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h2><p>string 类是模板类，可以当作char的替代品，使用string类要包含头文件&lt; string &gt;</p>
<p>string对象的三种初始化方式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>; </span><br><span class="line">string month = <span class="string">"March"</span>; <span class="comment">//要以字符串的形势初始化</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">8</span>,’x’)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>可以将字符赋给string对象：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s = ‘n’;</span><br></pre></td></tr></tbody></table></figure>
<p>string类可以用getline读入：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="string的赋值-连接与比较"><a href="#string的赋值-连接与比较" class="headerlink" title="string的赋值,连接与比较"></a>string的赋值,连接与比较</h3><p>• 用 = 赋值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"cat"</span>)</span>, s2</span>;</span><br><span class="line">s2 = s1; </span><br></pre></td></tr></tbody></table></figure>
<p>• 用 assign 成员函数复制</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"cat"</span>)</span>, s3</span>; </span><br><span class="line">s3.<span class="built_in">assign</span>(s1); </span><br></pre></td></tr></tbody></table></figure>
<p>• 用 assign 成员函数部分复制</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"catpig"</span>)</span>, s3</span>; </span><br><span class="line">s3.<span class="built_in">assign</span>(s1, <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//从s1 中下标为1的字符开始复制3个字符给s3</span></span><br></pre></td></tr></tbody></table></figure>
<p>• 单个字符复制</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">s2[<span class="number">5</span>] = s1[<span class="number">3</span>] = ‘a’;</span><br></pre></td></tr></tbody></table></figure>
<p>• 逐个访问string对象中的字符</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>成员函数at会做范围检查，如果超出范围，会抛出 out_of_range异常，而下标运算符[]不做范围检查。</p>
<p>• 用 + 运算符连接字符串</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"good "</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">"morning! "</span>)</span></span>;</span><br><span class="line">s1 += s2;</span><br><span class="line">cout &lt;&lt; s1;</span><br></pre></td></tr></tbody></table></figure>
<p>• 用成员函数 append 连接字符串</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"good "</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">"morning! "</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">append</span>(s2);</span><br><span class="line">cout &lt;&lt; s1;</span><br><span class="line">s2.<span class="built_in">append</span>(s1, <span class="number">3</span>, s1.<span class="built_in">size</span>());<span class="comment">//s1.size()，s1字符数</span></span><br><span class="line">cout &lt;&lt; s2;</span><br><span class="line"><span class="comment">// 下标为3开始，s1.size()个字符，如果字符串内没有足够字符，则复制到字符串最后一个字符</span></span><br></pre></td></tr></tbody></table></figure>
<p>• 用关系运算符比较string的大小</p>
<p>== , &gt;, &gt;=, &lt;, &lt;=, !=</p>
<p>返回值都是bool类型，成立返回true, 否则返回false</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">"hello"</span>)</span>,<span class="title">s3</span><span class="params">(<span class="string">"hell"</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> b = (s1 == s2); </span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">b = (s1 == s3); <span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">b = (s1 &gt; s3); <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<p>• 用成员函数compare比较string的大小</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">"hello"</span>)</span>,<span class="title">s3</span><span class="params">(<span class="string">"hell"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> f1 = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"><span class="keyword">int</span> f2 = s1.<span class="built_in">compare</span>(s3);</span><br><span class="line"><span class="keyword">int</span> f3 = s3.<span class="built_in">compare</span>(s1);</span><br><span class="line"><span class="keyword">int</span> f4 = s1.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,s3,<span class="number">0</span>,<span class="number">3</span>); <span class="comment">//s1 1-2; s3 0-3</span></span><br><span class="line"><span class="keyword">int</span> f5 = s1.<span class="built_in">compare</span>(<span class="number">0</span>,s1.<span class="built_in">size</span>(),s3);<span class="comment">//s1 0-end</span></span><br><span class="line">cout &lt;&lt; f1 &lt;&lt; endl &lt;&lt; f2 &lt;&lt; endl &lt;&lt; f3 &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; f4 &lt;&lt; endl &lt;&lt; f5 &lt;&lt; endl; </span><br></pre></td></tr></tbody></table></figure>
<h3 id="string-类的成员函数"><a href="#string-类的成员函数" class="headerlink" title="string 类的成员函数"></a>string 类的成员函数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">str.<span class="built_in">assign</span>()<span class="comment">//起复制作用，上文已提到</span></span><br><span class="line">str.<span class="built_in">at</span>()<span class="comment">//起访问的作用，上文已提到</span></span><br><span class="line">str.<span class="built_in">compare</span>()<span class="comment">//起比较的作用，上文已提到</span></span><br><span class="line">str.<span class="built_in">length</span>()<span class="comment">//返回字符串长度</span></span><br><span class="line">str.<span class="built_in">size</span>()<span class="comment">//返回字符串长度，和上面一样</span></span><br><span class="line">str.<span class="built_in">substr</span>()<span class="comment">//返回指定范围的子串</span></span><br><span class="line">str.<span class="built_in">swap</span>()<span class="comment">//交换字符串</span></span><br><span class="line"><span class="comment">/*以下带有find的成员函数在找不到时都会返回string::npos*/</span></span><br><span class="line">str.<span class="built_in">find_first_of</span>()<span class="comment">//从前向后找字符串中任何一个字符第一次出现的地方</span></span><br><span class="line">str.<span class="built_in">find_last_of</span>()<span class="comment">//从后往前找字符串中任何一个字符第一次出现的地方</span></span><br><span class="line">str.<span class="built_in">find_first_not_of</span>()<span class="comment">//从前向后找非字符串中任何一个字符的第一个字符</span></span><br><span class="line">str.<span class="built_in">find_last_not_of</span>()<span class="comment">//从后往前找非字符串中任何一个字符的第一个字符</span></span><br><span class="line">str.<span class="built_in">find</span>()<span class="comment">//返回找到的字符串的首字母位置，rfind()则是从后往前找</span></span><br><span class="line">str.<span class="built_in">erase</span>()<span class="comment">//删除指定范围的字符串</span></span><br><span class="line">str.<span class="built_in">replace</span>()<span class="comment">//替换指定范围的字符串</span></span><br><span class="line">str.<span class="built_in">insert</span>()<span class="comment">//在指定位置插入字符串</span></span><br><span class="line">str.<span class="built_in">c_str</span>()<span class="comment">//转换成C语言式const char *字符串</span></span><br><span class="line">str.<span class="built_in">data</span>()<span class="comment">//转换成C语言式char *字符串，不安全</span></span><br><span class="line">str.<span class="built_in">copy</span>()<span class="comment">//拷贝指定范围的字符串</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h2><h3 id="STL中的基本的概念"><a href="#STL中的基本的概念" class="headerlink" title="STL中的基本的概念"></a>STL中的基本的概念</h3><p><strong>容器</strong>：可容纳各种数据类型的通用数据结构,是<strong>类模板</strong> </p>
<p><strong>迭代器</strong>：可用于依次存取容器中元素，<strong>类似于指针</strong> </p>
<p><strong>算法</strong>：用来操作容器中的元素的<strong>函数模板</strong> </p>
<p>通俗理解：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">100</span>]; </span><br><span class="line"><span class="built_in">sort</span>(array,array+<span class="number">70</span>); <span class="comment">//将前70个元素排序</span></span><br></pre></td></tr></tbody></table></figure>
<p>该数组就是容器，而 int * 类型的指针变量就可以作为迭代器，sort算法可以作用于该容器上，对其进行排序</p>
<p>容器分为三种：</p>
<p>1)顺序容器 vector, deque(双向队列), list(链表)</p>
<p>2)关联容器 set, multiset, map, multimap </p>
<p>3)容器适配器 stack(栈), queue(队列), priority_queue(优先队列)</p>
<p>对象被插入容器中时，被插入的是对象的一个<strong>复制品</strong>。许多算法，比如排序，查找，要求对容器中的元 素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该<strong>重载 == 和 &lt;</strong> 运算符</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><strong>动态数组</strong>。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在<strong>尾端增删</strong>元素具有较佳的性能(大部分情况下是常数时间）</p>
<img src="/2022/02/10/34/1.jpg" class="" title="blog">
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p><strong>双向队列</strong>。元素在内存连续存放。随机存取任何元素都能在常数时间完成(但次于vector)。在<strong>两端增删</strong>元素具有较佳的性能(大部分情况下是常数时间)</p>
<img src="/2022/02/10/34/2.jpg" class="" title="blog">
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><strong>双向链表</strong>。元素在内存不连续存放。在<strong>任何位置增删</strong>元素都能在常数时间完成。<strong>不支持随机存取</strong></p>
<img src="/2022/02/10/34/3.jpg" class="" title="blog">
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>• 元素是<strong>排序</strong>的 </p>
<p>• 插入任何元素，都按相应的排序规则来确定其位置 </p>
<p>• 在<strong>查找</strong>时具有非常好的性能 </p>
<p>• 通常以<strong>平衡二叉树</strong>方式实现，插入和检索的时间都是 O(log(N))</p>
<h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>set 即集合。set中<strong>不允许</strong>相同元素，multiset中允许存在相同的元素</p>
<h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h4><p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first(表示关键字),另一个名为second(表示值), map<strong>根据first值对元素进行从小到大排序</strong>，并可快速地<strong>根据first来检索元素</strong>。 </p>
<p>map同multimap的不同在于是否允许相同first值的元素。</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。<strong>后进先出</strong>。</p>
<img src="/2022/02/10/34/4.jpg" class="" title="blog">
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。<strong>先进先出</strong>。</p>
<img src="/2022/02/10/34/5.jpg" class="" title="blog">
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先级队列。最高优先级(自己定义)元素总是第一个出列</p>
<h3 id="顺序容器和关联容器中都有的成员函数"><a href="#顺序容器和关联容器中都有的成员函数" class="headerlink" title="顺序容器和关联容器中都有的成员函数"></a>顺序容器和关联容器中都有的成员函数</h3><p><strong>begin</strong> 返回指向容器中第一个元素的迭代器 </p>
<p><strong>end</strong> 返回指向容器中最后一个元素后面的位置的迭代器 </p>
<p><strong>rbegin</strong> 返回指向容器中最后一个元素的迭代器 </p>
<p><strong>rend</strong> 返回指向容器中第一个元素前面的位置的迭代器 </p>
<p><strong>erase</strong> 从容器中删除一个或几个元素 </p>
<p><strong>clear</strong> 从容器中删除所有元素</p>
<h3 id="顺序容器的常用成员函数"><a href="#顺序容器的常用成员函数" class="headerlink" title="顺序容器的常用成员函数"></a>顺序容器的常用成员函数</h3><p><strong>front</strong> :返回容器中第一个元素的引用 </p>
<p><strong>back</strong> : 返回容器中最后一个元素的引用 </p>
<p><strong>push_back</strong> : 在容器末尾增加新元素 </p>
<p><strong>pop_back</strong> : 删除容器末尾的元素 </p>
<p><strong>erase</strong> :删除迭代器指向的元素(可能会使该迭代器失效），或删除一个区间，返回被删除元素后面的那个元素的迭代器</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>琐事记（2）</title>
    <url>/2022/02/21/35/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>As the begining of a year,spring has its familiar flavour.</p>
<p>With the soft wind and relax moods,we steps the new journey.</p>
<p>There should be a strong impluse for us to struggle for a better life,which pulls us out of our comfort zone.</p>
<p>Time is mean,but you can be more mean than time.</p>
<p>We embrase the pain,to cultivate our abilities.</p>
<p>We hold the ethic, to fit into the society.</p>
<p>When we get up at the spring of a day,we throw away all the sadness and happiness.</p>
<p>Be tolerant of ourselves.</p>
<p>Everything is as you wish.✨</p>
]]></content>
      <tags>
        <tag>memories</tag>
      </tags>
  </entry>
  <entry>
    <title>水一篇博客</title>
    <url>/2022/04/03/36/</url>
    <content><![CDATA[<h2 id="水文"><a href="#水文" class="headerlink" title="水文"></a>水文</h2><p>时间过得飞快，转眼间就来到了四月份。每天不停的忙碌着，不断地宽容别人，不断地安慰自己，看似一无所获，实则学了些许有用的东西。</p>
<img src="/2022/04/03/36/1.jpg" class="" title="blog">
<p>疫情似乎要陪我度过大学四年了，我还是挺乐观的，计算机的学生封不封校都一样，每天依旧忙碌着。在每一个忙碌的日子里，我不断地取舍，不断地思考，不断地罚座，时钟自顾自的走动，不曾为我动容。</p>
<p>没有信仰的人先入为主，觉得入积极分子是在浪费时间；过于功利的人开始摆烂，觉得上水课是在浪费生命。教育早已偏离了正轨，我们也将错就错。</p>
<p>身处于大学的幸福中，仿佛早已忘记高中留下的遗憾。只觉得待我们走入社会的牢笼，生活才会撕开它的笑容。</p>
<p>我们不必过于忧虑，但也不可昏睡过去，时常反问自己，是否依旧清醒。</p>
<p>我们不必困于过往，但也不能忘记耻辱，时常反思过去，只为更好前行。</p>
]]></content>
      <tags>
        <tag>meaningless</tag>
      </tags>
  </entry>
  <entry>
    <title>题型整理（1)</title>
    <url>/2022/04/23/37/</url>
    <content><![CDATA[<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p><strong>应用场景：</strong></p>
<p>1.n个节点能组成几种二叉树<br>2.括号匹配给出n对括号，求可以组成的合法表达式的个数<br>3.凸多边形的三角划分<br>4.一个顺序为1~n的进栈序列，有多少种出栈序列</p>
<p>卡特兰数求解代码（从0开始，用的组合数方法求）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fact[N];</span><br><span class="line">ll inv_fact[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>{</span><br><span class="line">	ll base=x,ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y){</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">			ret=ret*base%MOD;</span><br><span class="line">		base=base*base%MOD;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">	fact[<span class="number">0</span>]=inv_fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,inv;i&lt;N;++i){</span><br><span class="line">		fact[i]=(fact[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line">		inv=<span class="built_in">qpow</span>(i,MOD<span class="number">-2</span>);</span><br><span class="line">		inv_fact[i]=(inv_fact[i<span class="number">-1</span>]*inv)%MOD;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> ((fact[a]*inv_fact[b])%MOD*inv_fact[a-b])%MOD;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll ans=((<span class="built_in">C</span>(<span class="number">2</span>*n,n)-<span class="built_in">C</span>(<span class="number">2</span>*n,n<span class="number">-1</span>))%MOD+MOD)%MOD;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>题的变形：</p>
<p>括号匹配给出n对括号，k种括号，求可以组成的合法表达式的个数</p>
<p>答案就成了n的卡特兰数*pow(k,n)</p>
<h3 id="字符串不同子串个数"><a href="#字符串不同子串个数" class="headerlink" title="字符串不同子串个数"></a>字符串不同子串个数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">1</span>,lst=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn&lt;&lt;<span class="number">1</span>],len[maxn&lt;&lt;<span class="number">1</span>],son[maxn&lt;&lt;<span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> f=lst,p=++cnt; lst=p;</span><br><span class="line">	len[p]=len[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(f&amp;&amp;!son[f][c]) son[f][c]=p,f=fa[f];</span><br><span class="line">	<span class="keyword">if</span>(!f) {fa[p]=<span class="number">1</span>;<span class="keyword">return</span>;}</span><br><span class="line">	<span class="keyword">int</span> x=son[f][c];</span><br><span class="line">	<span class="keyword">if</span>(len[f]+<span class="number">1</span>==len[x]) {fa[p]=x;<span class="keyword">return</span>;}</span><br><span class="line">	<span class="keyword">int</span> y=++cnt;</span><br><span class="line">	len[y]=len[f]+<span class="number">1</span>,fa[y]=fa[x],fa[x]=fa[p]=y;</span><br><span class="line">	<span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) son[y][i]=son[x][i];</span><br><span class="line">	<span class="keyword">while</span>(f&amp;&amp;son[f][c]==x) son[f][c]=y,f=fa[f];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">ins</span>(S[i]-<span class="string">'a'</span>);</span><br><span class="line">	<span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++) ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)(len[i]-len[fa[i]]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串某一个子串的数目"><a href="#字符串某一个子串的数目" class="headerlink" title="字符串某一个子串的数目"></a>字符串某一个子串的数目</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">string s,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> len1,len2;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	len1=s.<span class="built_in">size</span>();</span><br><span class="line">	len2=t.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= len1 ; i++){</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len1 ; i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= len2 ; j++){</span><br><span class="line">            <span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;dp[len1][len2];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组不同子序列个数"><a href="#数组不同子序列个数" class="headerlink" title="数组不同子序列个数"></a>数组不同子序列个数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  mod  = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        vis[a[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(vis[a[i]]==<span class="number">0</span>){</span><br><span class="line">                dp[i] = (dp[i<span class="number">-1</span>]*<span class="number">2</span> + <span class="number">1</span>)%mod;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i] = (dp[i<span class="number">-1</span>]*<span class="number">2</span> - dp[ vis[a[i]] - <span class="number">1</span> ] + mod) % mod;</span><br><span class="line">            }</span><br><span class="line">            vis[a[i]]=i;</span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="两端相等子数组最大和，返回最后一次相等左，右位置和"><a href="#两端相等子数组最大和，返回最后一次相等左，右位置和" class="headerlink" title="两端相等子数组最大和，返回最后一次相等左，右位置和"></a>两端相等子数组最大和，返回最后一次相等左，右位置和</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">210000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--){</span><br><span class="line">		<span class="keyword">int</span> n,sum=<span class="number">0</span>,sum1=<span class="number">0</span>,l;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		cin&gt;&gt;num[i],sum+=num[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">			sum1+=num[i];</span><br><span class="line">			<span class="keyword">if</span>(sum1&gt;=sum/<span class="number">2</span>){</span><br><span class="line">				l=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> r=l+<span class="number">1</span>,sum2=sum-sum1;</span><br><span class="line">		<span class="keyword">while</span>(sum1!=sum2){</span><br><span class="line">			<span class="keyword">if</span>(sum1&gt;sum2)</span><br><span class="line">			sum1-=num[l--];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			sum2-=num[r++];</span><br><span class="line">		}</span><br><span class="line">		cout&lt;&lt;l+n-r+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年蓝桥杯省赛C++B组部分题解</title>
    <url>/2022/04/25/38/</url>
    <content><![CDATA[<h2 id="试题-A-九进制转十进制"><a href="#试题-A-九进制转十进制" class="headerlink" title="试题 A: 九进制转十进制"></a><strong>试题 A: 九进制转十进制</strong></h2><p>本题总分：5 分<br><strong>【问题描述】</strong><br>九进制正整数2022转换成十进制等于多少？</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	t=<span class="number">2</span>*<span class="built_in">pow</span>(<span class="number">9</span>,<span class="number">3</span>)+<span class="number">2</span>*<span class="number">9</span>+<span class="number">2</span>;</span><br><span class="line">	cout&lt;&lt;t;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="试题-B-顺子日期"><a href="#试题-B-顺子日期" class="headerlink" title="试题 B: 顺子日期"></a>试题 B: 顺子日期</h2><p>本题总分：5 分<br><strong>【问题描述】</strong><br>小明特别喜欢顺子。顺子指的就是连续的三个数字：123、456 等。顺子日<br>期指的就是在日期的 yyyymmdd 表示法中，存在任意连续的三位数是一个顺子的日期。例如 20220123 就是一个顺子日期，因为它出现了一个顺子：123； 而 20221023 则不是一个顺子日期，它一个顺子也没有。小明想知道在整个 2022年份中，一共有多少个顺子日期。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">20220120</span></span><br><span class="line"><span class="number">20220121</span></span><br><span class="line"><span class="number">20220122</span></span><br><span class="line"><span class="number">20220123</span></span><br><span class="line"><span class="number">20220124</span></span><br><span class="line"><span class="number">20220125</span></span><br><span class="line"><span class="number">20220126</span></span><br><span class="line"><span class="number">20220127</span></span><br><span class="line"><span class="number">20220128</span></span><br><span class="line"><span class="number">20220129</span></span><br><span class="line"><span class="number">20221012</span></span><br><span class="line"><span class="number">20221123</span></span><br><span class="line"><span class="number">20221230</span></span><br><span class="line"><span class="number">20221231</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="试题-C-刷题统计"><a href="#试题-C-刷题统计" class="headerlink" title="试题 C: 刷题统计"></a>试题 C: 刷题统计</h2><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：10 分<br><strong>【问题描述】</strong><br>小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天<br>做 a 道题目，周六和周日每天做 b 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 n 题？<br><strong>【输入格式】</strong><br>输入一行包含三个整数 a, b 和 n.<br><strong>【输出格式】</strong><br>输出一个整数代表天数。<br><strong>【样例输入】</strong><br>10 20 99<br><strong>【样例输出】</strong><br>8<br><strong>【评测用例规模与约定】</strong><br>对于 50% 的评测用例，1 ≤ a, b, n ≤ 1e6.<br>对于 100% 的评测用例，1 ≤ a, b, n ≤ 1e18.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ll n,m,k,t,chu,mo,flag=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	t=n*<span class="number">5</span>+m*<span class="number">2</span>;</span><br><span class="line">	chu=k/t;</span><br><span class="line">	chu*=<span class="number">7</span>;</span><br><span class="line">	mo=k%t;</span><br><span class="line">	<span class="keyword">if</span>(mo&gt;<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>(mo&lt;i*n){</span><br><span class="line">				chu+=i;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++){</span><br><span class="line">			<span class="keyword">if</span>(mo&lt;i*m+n*<span class="number">5</span>&amp;&amp;flag==<span class="number">0</span>){</span><br><span class="line">				chu+=i+<span class="number">5</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout&lt;&lt;chu;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="试题-D-修剪灌木"><a href="#试题-D-修剪灌木" class="headerlink" title="试题 D: 修剪灌木"></a>试题 D: 修剪灌木</h2><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：10 分<br><strong>【问题描述】</strong><br>爱丽丝要完成一项修剪灌木的工作。<br>有 N 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晚会修剪一棵灌<br>木，让灌木的高度变为 0 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。灌木每天从早上到傍晚会长高 1 厘米，而其余时间不会长高。在第一天的早晨，所有灌木的高度都是 0 厘米。爱丽丝想知道每棵灌木最高长到多高。<br><strong>【输入格式】</strong><br>一个正整数 N ，含义如题面所述。<br><strong>【输出格式】</strong><br>输出 N 行，每行一个整数，第行表示从左到右第 i 棵树最高能长到多高。<br><strong>【样例输入】</strong><br>3<br><strong>【样例输出】</strong><br>4<br>2<br>4<br><strong>【评测用例规模与约定】</strong><br>对于 30% 的数据，N ≤ 10.<br>对于 100% 的数据，1 &lt; N ≤ 10000.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		cout&lt;&lt;<span class="number">2</span>*<span class="built_in">max</span>(i<span class="number">-1</span>,n-i)&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="试题-F-统计子矩阵"><a href="#试题-F-统计子矩阵" class="headerlink" title="试题 F: 统计子矩阵"></a>试题 F: 统计子矩阵</h2><p>时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分<br><strong>【问题描述】</strong><br>给定一个 N × M 的矩阵 A，请你统计有多少个子矩阵 (最小 1 × 1，最大<br>N × M) 满足子矩阵中所有数的和不超过给定的整数 K?<br><strong>【输入格式】</strong><br>第一行包含三个整数 N, M 和 K.<br>之后 N 行每行包含 M 个整数，代表矩阵 A.<br><strong>【输出格式】</strong><br>一个整数代表答案。<br><strong>【样例输入】</strong><br>3 4 10<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br><strong>【样例输出】</strong><br>19<br><strong>【样例说明】</strong><br>满足条件的子矩阵一共有 19，包含：<br>大小为 1 × 1 的有 10 个。<br>大小为 1 × 2 的有 3 个。<br>大小为 1 × 3 的有 2 个。<br>大小为 1 × 4 的有 1 个。<br>大小为 2 × 1 的有 3 个。<br><strong>【评测用例规模与约定】</strong><br>对于 30% 的数据，N, M ≤ 20.<br>对于 70% 的数据，N, M ≤ 100.<br>对于 100% 的数据，1 ≤ N, M ≤ 500; 0 ≤ Ai j ≤ 1000; 1 ≤ K ≤ 250000000.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2100</span>][<span class="number">2100</span>],s[<span class="number">2100</span>][<span class="number">2100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> n,m,k,ret=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		cin&gt;&gt;a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		a[i][j]=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){<span class="comment">//x1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> f=i;f&lt;=n;f++){<span class="comment">//x2</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){<span class="comment">//y1</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;=m;b++){<span class="comment">//y2</span></span><br><span class="line">						ret=a[f][b]-a[f][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][b]+a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">						<span class="keyword">if</span>(ret&lt;=k)</span><br><span class="line">						cnt++;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>题型整理（2）</title>
    <url>/2022/04/30/39/</url>
    <content><![CDATA[<h2 id="古代猪文"><a href="#古代猪文" class="headerlink" title="古代猪文"></a>古代猪文</h2><h4 id="213-古代猪文-AcWing题库"><a href="#213-古代猪文-AcWing题库" class="headerlink" title="213. 古代猪文 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/215/">213. 古代猪文 - AcWing题库</a></h4><p>数论好题</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">37000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">999911658</span>;</span><br><span class="line"><span class="keyword">int</span> plist[<span class="number">5</span>] = {<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4679</span>,<span class="number">35617</span>};</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> a1,a2,a3,a4;</span><br><span class="line"><span class="keyword">int</span> fac[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> power,<span class="keyword">int</span> mod)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power) {</span><br><span class="line">        <span class="keyword">if</span>(power &amp; <span class="number">1</span>) {</span><br><span class="line">            res = res * base % mod;</span><br><span class="line">        }</span><br><span class="line">        base = base * base % mod;</span><br><span class="line">        power = power &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>{</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mod ; i ++)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span> </span>{<span class="comment">//预处理阶乘的逆元</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ksm</span>(fac[x],mod - <span class="number">2</span>,mod);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> mod)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * <span class="built_in">ni</span>(m,mod) % mod * <span class="built_in">ni</span>(n - m,mod) % mod;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> mod)</span> </span>{<span class="comment">//卢卡斯定理</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Lucas</span>(n / mod,m / mod,mod) * <span class="built_in">C</span>(n % mod,m % mod,mod) % mod;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">memge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> &amp;a1,<span class="keyword">long</span> <span class="keyword">long</span> &amp;m1,<span class="keyword">long</span> <span class="keyword">long</span> a2,<span class="keyword">long</span> <span class="keyword">long</span> m2)</span> </span>{<span class="comment">//合并素数</span></span><br><span class="line">    <span class="keyword">if</span>(m2&gt;m1) <span class="built_in">swap</span>(m1,m2),<span class="built_in">swap</span>(a1,a2);</span><br><span class="line">    <span class="keyword">while</span>(a1%m2!=a2)a1=a1+m1;</span><br><span class="line">    m1 =(m2/<span class="built_in">gcd</span>(m1,m2))*m1;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRT</span><span class="params">()</span> </span>{<span class="comment">//扩展中国剩余定理</span></span><br><span class="line">    <span class="keyword">int</span> m1 = plist[<span class="number">1</span>],a1 = a[<span class="number">1</span>];</span><br><span class="line">    a1 %= m1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= <span class="number">4</span> ; i ++) {</span><br><span class="line">        <span class="keyword">int</span> m2 = plist[i],a2 = a[i];</span><br><span class="line">        a2 %= m2;</span><br><span class="line">        <span class="built_in">memge</span>(a1,m1,a2,m2);</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;<span class="built_in">ksm</span>(q,(a1 + m1) % m1,MOD + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">if</span>(q % (MOD + <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; i ++) {</span><br><span class="line">        <span class="built_in">init</span>(plist[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j * j &lt;= n ; j ++) {</span><br><span class="line">            <span class="keyword">if</span>(n % j == <span class="number">0</span>) {</span><br><span class="line">                a[i] = (a[i] + <span class="built_in">Lucas</span>(n,j,plist[i])) % plist[i];</span><br><span class="line">                <span class="keyword">if</span>(j * j != n) {</span><br><span class="line">                    a[i] = (a[i] + <span class="built_in">Lucas</span>(n,n / j,plist[i])) % plist[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">CRT</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><a href="http://oj.daimayuan.top/course/10/problem/664">数列 - 题目 - Daimayuan Online Judge</a></p>
<p>思维题</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; d &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = d;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tmp; i &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        tmp -= i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(tmp) v.<span class="built_in">push_back</span>(tmp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    	ans = ans * v[i] % m;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!ans) ans = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ans--;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h2><p>n种物品，第i种物品有ai个，不同种类物品可以互相区分但是相同种类无法区分。从这些物品中取出m个，求方案数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,tot,s,b;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;tot,&amp;s,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        a[tmp]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-1</span>-<span class="built_in">min</span>(j,a[i])&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=(dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j]-dp[i<span class="number">-1</span>][j<span class="number">-1</span>-<span class="built_in">min</span>(j,a[i])]+MOD)%MOD;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=(dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j])%MOD;             </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=b;i++)</span><br><span class="line">        ans=(dp[n][i]+ans)%MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>题型整理（3）</title>
    <url>/2022/05/02/40/</url>
    <content><![CDATA[<h2 id="余数之和-acwing199"><a href="#余数之和-acwing199" class="headerlink" title="余数之和(acwing199)"></a>余数之和(acwing199)</h2><p>给出正整数 n 和 k，计算 j(n,k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n 的值。</p>
<p>例如j(5,3) = 3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5 = 0 + 1 + 0 + 3 + 3 = 7。</p>
<p><strong>输入格式</strong></p>
<p>输入仅一行，包含两个整数 n,,k。</p>
<p><strong>输出格式</strong></p>
<p>输出仅一行，即 j(n,k)。</p>
<p><strong>数据范围</strong></p>
<p>1≤n,k≤10^9</p>
<p><strong>输入样例</strong></p>
<p>5 3</p>
<p><strong>输出样例</strong></p>
<p>7</p>
<p>思路：</p>
<p>整除分块：</p>
<script type="math/tex; mode=display">
\displaystyle\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor</script><p>(它喵的，不知道别人网站里的公式可以复制，自己学了半天mathjax语法)</p>
<p>$\lfloor x \rfloor$表示对x向下取整，通过打表可以发现n/i会有多个相等的区间，区间的右端点即为n/(n/i),则整除分块的代码为：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>){</span><br><span class="line">	r=n/(n/l);</span><br><span class="line">	ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而本题的答案为</p>
<script type="math/tex; mode=display">
ans=n*k-\displaystyle\sum_{i=1}^n\lfloor\frac{k}{i}\rfloor*i</script><p>只要通过等差数列求和公式就能推出每个区间要减去(k/l)(r-l+1)(l+r)/2</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    ll ans=n*k;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(k/l!=<span class="number">0</span>) r=<span class="built_in">min</span>(k/(k/l),n); </span><br><span class="line">        <span class="keyword">else</span> r=n;</span><br><span class="line">        ans-=(k/l)*(r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>Fill an n×n matrix with numbers in [1,n2], where each number occurs exactly once.</p>
<p>For a fixed number filling method, let ai be the mininum number in the iith row, and S={a1,a2,…,an}∩{1,2,…,n}.</p>
<p>You need to calculate ∑|S|(mod998244353), i.e. the sum of the size of S over all possible methods.</p>
<p><strong>Input</strong></p>
<p>This problem contains multiple test cases.</p>
<p>The first line contains a single integer T (1≤T≤30).</p>
<p>Then T cases follow, each of which contains a single interger n (1≤n≤5000).</p>
<p><strong>Output</strong></p>
<p>For each test case, output one line contains the value of ∑|S|(mod998244353)</p>
<p><strong>input</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure>
<p><strong>output</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">40</span><br></pre></td></tr></tbody></table></figure>
<p>思路：<br>考虑每一个数的贡献，比如1可以作为贡献的方案数就是n <em> C(n </em> n-1,n-1)<br>其中组合数部分表示1作为该行的最小值出现，选择剩下的数的方案数；n表示该行可以出现在1-n里任意一行。<br>最后还要乘n ! ∗ ( n * n − n ) !，前者表示1所在行的所有数都可以全排列一遍，后者表示剩下的数可以全排列,然后累加出1 − n的贡献</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">ll fac[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">    {</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">infac</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(x, mod - <span class="number">2</span>, mod);</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * <span class="built_in">infac</span>(fac[m]) % mod * <span class="built_in">infac</span>(fac[n - m]) % mod;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    {</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        ll ans = n * fac[n] % mod * fac[n * n - n] % mod;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        {</span><br><span class="line">            sum += <span class="built_in">C</span>(n * n - i, n - <span class="number">1</span>);</span><br><span class="line">            sum = sum % mod;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * sum % mod);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉定理的应用:Counting regions</title>
    <url>/2022/05/10/41/</url>
    <content><![CDATA[<h2 id="欧拉定理的应用：Counting-regions"><a href="#欧拉定理的应用：Counting-regions" class="headerlink" title="欧拉定理的应用：Counting regions"></a>欧拉定理的应用：Counting regions</h2><p><a href="https://ac.nowcoder.com/acm/problem/17369">Counting regions</a></p>
<p>Niuniu likes mathematics. He also likes drawing pictures. One day, he was trying to draw a regular polygon with n vertices. He connected every pair of the vertices by a straight line as well. He counted the number of regions inside the polygon after he completed his picture. He was wondering how to calculate the number of regions without the picture. Can you calculate the number of regions modulo 1000000007? <strong>It is guaranteed that n is odd.</strong></p>
<p>在图论里有这样一个定理：</p>
<p><strong>对于一个平面图，顶点数-边数+面数=2</strong></p>
<p>我最早看到这个式子是在浙大的高中数学竞赛书中，最近离散数学课也推到图论了，里面讲到了这场多校赛的两个基础知识点，欧拉定理和哈密顿图。</p>
<p>我当时只知道，n阶完全图的边数为C(n,2)，欧拉公式只适用于立体图；</p>
<p>一开始想找找规律，wa了两发；</p>
<p>后来我想，如果把完全图看作一个立体图，也就是说<strong>n阶完全图还有一个由外围的n个点形成的面</strong>。</p>
<p>这样我们要求的区域数再+1就是立体图的面数；</p>
<p>到这里只需要分别求出顶点数和边数就能带式子了：</p>
<p>顶点数：我们可以这么想每一个内部的交点都是由两条线相交构成的，这个线的两端点是从外面一圈点中选的，那么内部的交点数就相当于从外围的个点中选四个数，构成两条线，两条线再构成一个交点，即交点数为C(n,4)，然后还要加上外围的n个点，所以顶点数为C(n,4)+n；</p>
<img src="/2022/05/10/41/1.jpg" class="" title="blog">
<p>边数：尤其要注意的是，对角线之间互相切割的线段才是边，我们首先知道n阶完全图的边数是C(n,2)，同时我们注意到上图中每形成一个交点都会使两条对角线互相切割，切割成了4段，也就是比原边数多了两段，也就是交点数 <em> 2，即C(n,4) </em> 2，然后再把C(n,2)加上就行了，于是边数也就是C(n,4) * 2+C(n,2)；</p>
<p>带入公式：</p>
<p>C(n,4)+n-C(n,4) * 2-C(n,2)+x=2;</p>
<p>x=qu+1;</p>
<p>于是求得</p>
<p>qu=C(n,4)+1-n;</p>
<p>接下来用组合数求就行了；</p>
<p>当然要用到费马小定理求逆元，就不再赘述了</p>
<p>代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll k,ll p)</span></span>{</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k){</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=(ll)res*a%p;</span><br><span class="line">        a=(ll)a*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a,j=<span class="number">1</span>;j&lt;=b;i--,j++){</span><br><span class="line">        x=(ll)x*i%p;</span><br><span class="line">        y=(ll)y*j%p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x*(ll)<span class="built_in">qmi</span>(y,p<span class="number">-2</span>,p)%p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(ll a,ll b,<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (a&lt;p&amp;&amp;b&lt;p) <span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);</span><br><span class="line">    <span class="keyword">return</span> (ll)<span class="built_in">C</span>(a%p,b%p,p)*<span class="built_in">lucas</span>(a/p,b/p,p)%p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ll n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;(((<span class="built_in">C</span>(n,<span class="number">2</span>,M)%M+<span class="built_in">C</span>(n,<span class="number">4</span>,M)%M)%M)%M+(<span class="number">1</span>-n+M)%M)%M;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这着实是个好题，但不太正经。。。</p>
]]></content>
      <tags>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>思语(1)</title>
    <url>/2022/05/26/42/</url>
    <content><![CDATA[<h2 id="思语"><a href="#思语" class="headerlink" title="思语"></a>思语</h2><p><strong>1.变得愈发少言，愈发令我欢喜。</strong></p>
<p><strong>2.不只是幽默，沉默也是交谈的艺术。</strong></p>
<p><strong>3.捂上耳朵，闭上眼睛，便可以倾听心语。</strong></p>
<p><strong>4.我希望自己宽以待人，严于律己。</strong></p>
<p><strong>5.旅途中若瞥见风景，便用心去欣赏，到达目的地，便用心去做事。</strong></p>
<p><strong>6.这个世界仿佛是只需看你一时的惊艳，便知晓你十年的汗水似的。</strong></p>
<p><strong>7.再多的悲伤与欢乐，都将在梦醒时索然无味。</strong></p>
<p><strong>8.纵使我们忘记了许多任何事，也不能忘记自己的存在。</strong></p>
<p><strong>9.如果你有海一般的胸怀，放大幸福、淡化苦痛也不再是什么难事了。</strong></p>
<p><strong>10.为了活出自我，我们要少一些伪装的行径，呈现出自己真实的一面。</strong></p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly图标不能加载的问题（cdn更换）</title>
    <url>/2022/06/07/43/</url>
    <content><![CDATA[<h2 id="butterfly图标不能加载的问题"><a href="#butterfly图标不能加载的问题" class="headerlink" title="butterfly图标不能加载的问题"></a>butterfly图标不能加载的问题</h2><p>期末考试的我兴奋的打开网站，却发现图标君不在了，这对我这种菜狗来说是搞不明白的😥</p>
<p>f12一下看到有很多cdn.jsdelivr.net的文件出现了网络问题</p>
<p>于是我挂上梯子试了试，发现图片正常显示了，但我一直不知道为什么</p>
<p>直到我搜到相同的问题，才发现jsdelivr的cdn在5月17日挂了</p>
<p><a href="https://blog.zhheo.com/p/790087d9.html">这里</a>是一位大佬发的butterfly主题的cdn更换教程，等jsdelivr修好了再说吧</p>
<p>只需要把主题配置文件下的cdn更换即可</p>
<p>我不懂什么seo，也没打算用国内的服务器什么的，网站图片加载速度太慢什么的以后再说吧🤦‍♂️（摆烂ing）</p>
]]></content>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门笔记（4）</title>
    <url>/2021/08/20/eight/</url>
    <content><![CDATA[<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">3</span>] [<span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>代表定义了一个3行5列的二维数组</p>
<p>但a [2] [4]</p>
<p>指的是数组中第3行第5列的那个元素</p>
<span id="more"></span>
<p>因为计算机是<strong>从0开始数数</strong>的</p>
<p>多维数组也可借此类推</p>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [] [<span class="number">5</span>] = {</span><br><span class="line">{<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>}</span><br><span class="line">{<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>}</span><br><span class="line">}</span><br><span class="line">也可以将元素放在一行，只是不便阅读</span><br><span class="line"><span class="keyword">int</span> a [] [<span class="number">5</span>] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>列数必须给出，行数可以省略，由编译器来数</p>
<p>每行一个{}，逗号分隔</p>
<p>最后的逗号可以存在</p>
<p>如果省略了元素，表示补零</p>
<p>也可以用定位（c99 only)</p>
<h2 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h2><p>sizeof可以表示出某个类型或变量在内存中占据的字节数</p>
<p>因此数组的元素个数可以用<strong>sizeof(a)/sizeof(a[0])</strong>表示</p>
<p>这样表述的好处是，一旦修改数组中初始的数据，不需要再修改遍历的代码</p>
<h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span> b[] = a;</span><br></pre></td></tr></tbody></table></figure>
<p>这是不可行的</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[] = <span class="keyword">int</span> <span class="keyword">const</span> b[]</span><br></pre></td></tr></tbody></table></figure>
<p>b[]被定义后具有了常属性，不能直接赋值给另一个数组</p>
<p>但可以让b数组遍历读入a数组的每一个元素，完成所谓的复制，代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++ )</span><br><span class="line">{</span><br><span class="line">b[i] = a[i];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//遍历数组做赋值</span></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span> ( k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ ) </span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d "</span>,b[k]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//遍历输出b数组</span></span><br></pre></td></tr></tbody></table></figure>
<img src="/2021/08/20/eight/1.jpg" class="" title="blog">
<p>结果正确，但有些人遍历输出时也用了i</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++ )</span><br><span class="line">{</span><br><span class="line">b[i] = a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++ ) </span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d "</span>,b[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行确实没问题，但要指出的是：<font color="red">一专多能是不好的代码</font></p>
<p>当然也可以用<strong>指针</strong>，这里不再赘述</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>一维数组的遍历可以用一个for循环</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ ) {</span><br><span class="line">    a [i] = ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>二维数组的遍历则需要用两个for循环</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ ) {</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) {</span><br><span class="line">        a [i] [j] = ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>遍历数组可以做数组的初始化，可以输出数组，可以搜索数组中的元素等等</p>
<p>在遍历时一般用for循环，<font color="red">最好用0和&lt;</font>,而不是1和&lt;=,因为前者遍历时最大的i<font color="red">恰好是数组的最大下标</font></p>
<h2 id="运算符-amp"><a href="#运算符-amp" class="headerlink" title="运算符&amp;"></a>运算符&amp;</h2><h3 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h3><p>使用&amp;可以获得变量的地址，地址的大小是否与int相同取决于编译器是32位还是64位</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>,&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;i);</span><br></pre></td></tr></tbody></table></figure>
<p>所以要输出一个变量的地址时，更应该用%p而不是%x，%x只是把地址当成一个16进制的整数，地址并不总和整数相同</p>
<h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a>数组的地址</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;a[<span class="number">1</span>]);</span><br><span class="line">结果为：</span><br><span class="line"><span class="number">0xbff8dd44</span></span><br><span class="line"><span class="number">0xbff8dd44</span></span><br><span class="line"><span class="number">0xbff8dd44</span></span><br><span class="line"><span class="number">0xbff8dd48</span></span><br></pre></td></tr></tbody></table></figure>
<p>从中我们可以看出地址&amp;a == a == a[0]，且相邻的元素差4个字节</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针就是保存地址的变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p == <span class="keyword">int</span> *p</span><br></pre></td></tr></tbody></table></figure>
<p>两种写法都一样,类型是int,不是int*</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i;</span><br></pre></td></tr></tbody></table></figure>
<p>i的地址传给了*p,也就是说p指向了i</p>
<h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>普通变量的值是实际的值</p>
<p>指针变量的值是具有实际值的地址</p>
<h3 id="作为参数的指针"><a href="#作为参数的指针" class="headerlink" title="作为参数的指针"></a>作为参数的指针</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>;</span><br><span class="line">f( &amp;i );</span><br></pre></td></tr></tbody></table></figure>
<p>参数是普通变量的地址</p>
<p>在这个函数内可以通过这个指针访问外面的变量i</p>
<h3 id="运算符“-”"><a href="#运算符“-”" class="headerlink" title="运算符“ * ”"></a>运算符“ * ”</h3><p>*是一个单目运算符，用来访问指针的值所表示的地址上的变量</p>
<p>*P可以做左值和又值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = *p;</span><br><span class="line">*p = k + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组作为指针"><a href="#数组作为指针" class="headerlink" title="数组作为指针"></a>数组作为指针</h3><p>数组变量是特殊的指针,因为数组本身表达地址</p>
<p>因此对于int*p=a，无需用&amp;取地址，但是数组的单元表达的是变量，需要用&amp;取地址</p>
<p>即a == &amp;a[0],指针也可以用[]运算符</p>
<p>下面四种函数原型等价</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>另外在函数参数中数组相当于指针</p>
<h3 id="利用指针交换两个数组"><a href="#利用指针交换两个数组" class="headerlink" title="* 利用指针交换两个数组"></a>* 利用指针交换两个数组</h3><p>代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},b[<span class="number">3</span>]={<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>},t,i,*p1=a,*p2=b;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">{</span><br><span class="line">	t=*p1;</span><br><span class="line">    *p1=*p2;</span><br><span class="line">    *p2=t;</span><br><span class="line">	p1++;</span><br><span class="line">    p2++;</span><br><span class="line">}</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\t"</span>,a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\t"</span>,b[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="/2021/08/20/eight/2.jpg" class="" title="blog">
<p>结果正确</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char是一种整数，也是一种特殊的类型：字符。</p>
<p>用单引号表示的字符字面量：’a’,’1’</p>
<p>‘’也是一个字符</p>
<p>printf和scanf里用%c输入字符</p>
<h3 id="字符的输入输出"><a href="#字符的输入输出" class="headerlink" title="字符的输入输出"></a>字符的输入输出</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">char</span> i = <span class="string">'1'</span>;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">"%c"</span>,&amp;i );得到<span class="number">1</span></span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">"%d"</span>,&amp;i );得到<span class="number">49</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为’1‘的ASCII编码是49</p>
<h3 id="混合输入"><a href="#混合输入" class="headerlink" title="混合输入"></a>混合输入</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">scanf</span>(<span class="string">"%d %c"</span>,&amp;i,&amp;c);</span><br><span class="line"><span class="number">2.</span><span class="built_in">scanf</span>(<span class="string">"%d%c"</span>,&amp;i,&amp;c);</span><br></pre></td></tr></tbody></table></figure>
<p>二者不同，在于2中读取输入的两个值时，如果有空格会读取空格，空格的ASCII码为32</p>
<h3 id="字符计算"><a href="#字符计算" class="headerlink" title="字符计算"></a>字符计算</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c =<span class="string">'A'</span>;</span><br><span class="line">c++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,c);</span><br><span class="line">结果为B    </span><br></pre></td></tr></tbody></table></figure>
<p>说明一个字符加一个数字得到ASCII码表中那个数之后的字符</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="string">'Z'</span>-<span class="string">'A'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">结果为<span class="number">25</span></span><br></pre></td></tr></tbody></table></figure>
<p>说明两个字符的减，得到的是它们在表中的距离</p>
<p>大小写转换也可以通过字符计算实现</p>
<h3 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h3><p>用来表达<strong>无法印出的控制字符</strong>或<strong>特殊作用的字符</strong></p>
<img src="/2021/08/20/eight/3.jpg" class="" title="blog">
<p>要指出的是回车和换行是两个动作，只是编译器顺带着换行一起执行了</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> word[] = {<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'!'</span>,<span class="string">'\0'</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串以数组形式存在，以数组或指针的形式访问</p>
<p>\0是结束的标志，它不是字符串的一部分，但它占用一个字节的空间</p>
<p>string.h 里有很多处理字符的函数</p>
<p>两个相邻的字符串常量会相连</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"123"</span></span><br><span class="line">       <span class="string">"456"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>会输出123456</p>
<p>另外不能用运算符对字符串做运算</p>
<p>”a“就相当于对a做了初始化</p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串初始化后便不可变，字符串在内存中是<font color="red">只读</font>的</p>
<p>用指针改变字符串会触发系统的保护机制，引起严重后果</p>
<h3 id="字符串的赋值"><a href="#字符串的赋值" class="headerlink" title="字符串的赋值"></a>字符串的赋值</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *t = <span class="string">"title"</span>;</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">s = t;</span><br></pre></td></tr></tbody></table></figure>
<p>这样做只是让指针s指向了t所指的字符串，并没有产生新的字符串</p>
<h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>]</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br></pre></td></tr></tbody></table></figure>
<p>scanf的读入是不安全的，因为不知道要读入的内容的长度</p>
<p>但可以这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>]</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%7s"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%7s"</span>,a);</span><br></pre></td></tr></tbody></table></figure>
<p>“7”告诉了scanf最多读7个</p>
<p>两个scanf可以连续读入</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>char*a不能直接用，要先对a初始化，否则出不出错就靠运气了</p>
<p>终于码完了。。。</p>
<font color="cornflowerblue">C语言入门篇完结！！！</font>

]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言程序设计进阶（3）</title>
    <url>/2021/10/16/eighteenth/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="why链表"><a href="#why链表" class="headerlink" title="why链表"></a>why链表</h3><span id="more"></span>
<p>如果创建一个结构，用malloc直接向内存申请<strong>一大片空间</strong>，那么为了实现数组的<strong>“扩大”</strong>，我们只能创建新的结构（一个更大的，加上增加空间的结构），如果内存不够上一次申请的内存的两倍，就会报错，很明显，这样的方法的<strong>空间利用率还不够高</strong>，因此，我们可以单独存储每一个数据以及数据间的关系（指针），也就可以使用链式存储，即<strong>链表</strong></p>
<h3 id="用链表实现可变数组"><a href="#用链表实现可变数组" class="headerlink" title="用链表实现可变数组"></a>用链表实现可变数组</h3><p>下面是原课件的程序：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node* head=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">        <span class="keyword">if</span>(number!=<span class="number">-1</span>){</span><br><span class="line">            Node *p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            p-&gt;value=number;</span><br><span class="line">            p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            Node *last=head;</span><br><span class="line">            <span class="keyword">if</span>(last){</span><br><span class="line">				<span class="keyword">while</span>(last-&gt;next){</span><br><span class="line">                last=last-&gt;next;</span><br><span class="line">            }</span><br><span class="line">              last-&gt;next=p;</span><br><span class="line">           }<span class="keyword">else</span>{</span><br><span class="line">                head=p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">while</span>(number!=<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>node. h :</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NODE_H_</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a>链表的函数</h3><p>待更新。。。</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年追过的神游</title>
    <url>/2021/09/01/eleventh/</url>
    <content><![CDATA[<p>以前总觉得游戏是个贬义词，它带给我的负面影响远多于正面，现在回头看去，我反倒不后悔。我现在越发喜欢一些独立游戏，我想你只有体验过才会懂得，你能从中得到的不仅仅是成就感，更有感悟与感动，反思与成长</p>
<p>游戏没有排名，所以的良心之作都值得赞誉(含剧透，谨慎观看)</p>
<span id="more"></span>
<h2 id="1-传说之下（undertale"><a href="#1-传说之下（undertale" class="headerlink" title="1.传说之下（undertale)"></a>1.传说之下（undertale)</h2><img src="/2021/09/01/eleventh/1.jpg" class="" title="blog">
<p>我一向喜欢玩法新颖（不按套路出牌）的游戏，我们习惯了玩打怪升级的爽游，进了游戏，先入为主，逢怪必杀。在这个游戏中任何怪都可以被说服，你只需击破怪物内心的防线。相反，你的屠杀会让你负罪累累，游戏将对你以牙还牙。当你还没弄清怪物的立场，上去便是一刀，最终boss将没有“仁慈”这一选项。你如果耐心走入那些中二的，呆萌的怪物的心房，敌人会成为挚友，甚至留下求助的联系方式。你的经验和等级就是你最终boss的强度，你的firstblood会改变你的结局，见到与你无仇的npc,为何要兵戎相见？</p>
<p>独特之处：音乐完美贴合像素风，当你对怪物动情，最终boss能关闭游戏程序，一个按钮能有10次不同互动（细节）</p>
<p>游戏口碑：steam好评如潮，游戏音乐原声带steam排名第一，ign满分10分…</p>
<h2 id="2-泰拉瑞亚（terraria）"><a href="#2-泰拉瑞亚（terraria）" class="headerlink" title="2.泰拉瑞亚（terraria）"></a>2.泰拉瑞亚（terraria）</h2><img src="/2021/09/01/eleventh/2.jpg" class="" title="blog">
<p>这是一款2d像素沙盒游戏，这是我买的第一款游戏，刚买完就半价，emm…不亏！</p>
<p>游戏对新手可能不太友好，游戏的精彩也恰在过程之中，如果没有向导npc，你甚至不知道该做什么，我喜欢游戏的像素风收集感，激动人心的音乐，充满未知的欢喜，还有官方认可的玩家自制模组工具等等</p>
<p>游戏口碑：steam好评如潮，今年三月steam好评率第一登顶(把v社传送门2都超了)，3500万销量</p>
<h2 id="3-塞尔达荒野之息（The-Legend-of-Zelda-Breath-of-the-Wild）"><a href="#3-塞尔达荒野之息（The-Legend-of-Zelda-Breath-of-the-Wild）" class="headerlink" title="3.塞尔达荒野之息（The Legend of Zelda: Breath of the Wild）"></a>3.塞尔达荒野之息（The Legend of Zelda: Breath of the Wild）</h2><img src="/2021/09/01/eleventh/3.jpg" class="" title="blog">
<p>国外玩家口中极好的游戏，任天堂，wiiu独占，门槛较高，pc的cemu模拟器可以60帧运行</p>
<p>我通关了普通模式，被它的充满冒险元素的广阔大陆深深吸引。这款游戏刷新了玩家对开放世界游戏的认识，我们可能对这款游戏毫不知情，但我相信你一定看过原神的广告，或者说玩过原神，我不得不说原神真的从野炊中借鉴了不少，我今天刚刚通关了原神2.1剧情，其中的珊瑚宫我竟有些眼熟？！塞尔达卓拉高地的宫殿在我脑海中不停的浮现。。。原神就不多说了，玩法？跑图，传送锚点，爬山…野炊都有了，原神四个字形容“又肝又氪“，野炊七个字形容”不务正业的林克”</p>
<p>游戏口碑：ign满分10分，”拿奖拿到手软“，“野炊天下第一”</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我觉得，判断一款游戏是否诚意满满，就在它的细节，一个场景能有几个互动，能否更加ai智能一些，让游戏被赋予温度，代码可没有这么冰冷。国内为什么出不了3a大作？我想离不开利益</p>
<h3 id="我认为的佳作："><a href="#我认为的佳作：" class="headerlink" title="我认为的佳作："></a>我认为的佳作：</h3><p>1.传说之下<br>3.传送门系列<br>4.泰拉瑞亚<br>5.双人成行<br>6.底特律变人<br>7.奇异人生1<br>8.我的世界<br>9.勇敢的心<br>10.古墓丽影9<br>11.abzu智慧之海<br>12.上古卷轴5<br>13.去月球<br>14.塞尔达系列<br>15.画中世界<br>16.纪念碑谷系列<br>17.寻声探路<br>18.未上锁的房间系列<br>19.最终幻想15<br>20.艾迪芬奇的记忆<br>21.半条命系列<br>22.超限域空间<br>23.雨中冒险2<br>24.死亡细胞<br>25.风之旅人<br>26.孩子们<br>27.修剪艺术<br>28.魔女之泉系列<br>29.信任的进化<br>30.绘真妙笔千山<br>31.寻找天堂<br>32.艾希<br>33.海之号角<br>34.生存战争系列</p>
<p>一些经典的游戏就不提了</p>
<h3 id="我仍在期待的几款游戏"><a href="#我仍在期待的几款游戏" class="headerlink" title="我仍在期待的几款游戏"></a>我仍在期待的几款游戏</h3><p>1.空洞骑士-丝之歌<br>2.黑神话悟空<br>3.上古卷轴6<br>4.最终幻想7重置版pc<br>5.我的世界1.18<br>6.森林之子<br>7.塞尔达荒野之息续作</p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工具和软件分享</title>
    <url>/2021/09/21/fifteenth/</url>
    <content><![CDATA[<h1 id="详情如下"><a href="#详情如下" class="headerlink" title="详情如下"></a>详情如下</h1><span id="more"></span>
<h2 id="1-f-lux（软件）"><a href="#1-f-lux（软件）" class="headerlink" title="1.f.lux（软件）"></a>1.f.lux（软件）</h2><p>硬核护眼软件，你可以输入经纬度让程序根据日出日落时间调整减少蓝光的程度</p>
<img src="/2021/09/21/fifteenth/1.jpg" class="" title="blog">
<img src="/2021/09/21/fifteenth/2.jpg" class="" title="blog">
<h2 id="2-wallhaven（网站）"><a href="#2-wallhaven（网站）" class="headerlink" title="2.wallhaven（网站）"></a>2.wallhaven（网站）</h2><p>4K壁纸网站，可以调整图片尺寸比例和分辨度，可根据颜色搜索</p>
<img src="/2021/09/21/fifteenth/3.jpg" class="" title="blog">
<h2 id="3-蓝调music（网站）"><a href="#3-蓝调music（网站）" class="headerlink" title="3.蓝调music（网站）"></a>3.蓝调music（网站）</h2><p>可以下载网易云，QQ音乐，酷狗音乐，百度音乐，虾米音乐五个平台的无损音乐，一些冷门纯音乐也可以搜到</p>
<img src="/2021/09/21/fifteenth/4.jpg" class="" title="blog">
<h2 id="4-greenhub（win10edge浏览器扩展）"><a href="#4-greenhub（win10edge浏览器扩展）" class="headerlink" title="4.greenhub（win10edge浏览器扩展）"></a>4.greenhub（win10edge浏览器扩展）</h2><p>就是魔法（vpn），可以让你访问外网，节点都比较稳定，近期可能是接近十一了，低调了些，建议大家节制使用，一般也用不到，想用的时候基本也找不到（免费的）</p>
<img src="/2021/09/21/fifteenth/5.jpg" class="" title="blog">
<p>祝各位中秋节快乐！！！<br>希望郑州早日开学。。。</p>
]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门笔记（1）</title>
    <url>/2021/08/17/fifth/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我觉得目前比较好的c语言入门网课有b站的失乐-try上传的C语言入门视频，以及中国大学mooc中浙大翁恺老师的<a href="https://www.icourse163.org/course/ZJU-199001">C语言程序设计入门视频</a>。都对新手友好到了极点。我这里选的是翁恺老师的课，比较系统，也比较专业。我会着重指出易错易忘的知识，以便复习，其他不再赘述。</p>
<span id="more"></span>
<p>关于对计算机知识的深入理解，我推荐b站搬运的YouTube的<a href="https://b23.tv/J0ghf3">计算机科学速成课</a>，里面把计算机的历史，发展，进化讲的<strong>相对容易</strong>理解些，虽然有些知识我听不懂，但我大为震撼。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>Windows系统推荐dev-C++，当然也可以线上编译，不过不能保存</p>
<h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span> ( <span class="string">"hello world\n"</span> );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>除了printf函数，剩下的是c语言的基本框架</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>a = 0;</p>
<p>把0赋值给a，a作为变量保存了数据0，a之后还可变为其它值。</p>
<p>a是一种标识符，<font color="red">只能有字母，数字，下划线组成，数字不能位于头部，关键字不能做标识符</font>。</p>
<p>关键字用多了就记住了，例如char,do,while,if,sizeof….</p>
<h2 id="赋值与初始化"><a href="#赋值与初始化" class="headerlink" title="赋值与初始化"></a>赋值与初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></tbody></table></figure>
<p>这里定义了一个变量a,但你不知道a是几，系统保存的可能是一个任意的数；</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在定义变量时，建议<font color="red">在代码开头的地方定义变量</font>，因为ansi c标准只能在代码开头的地方定义变量，c99标准则无此要求。</p>
<p>a被初始化为0，系统保存的a的值是0。</p>
<p><font color="red">初始化是一个好习惯</font>，不这样做可能会莫名报错，尤其到指针那一块。</p>
<h2 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br></pre></td></tr></tbody></table></figure>
<p>%d意为取整数a，&amp;取地址，让我输入a</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + b</span><br></pre></td></tr></tbody></table></figure>
<p>直接写在程序里的1是直接量，是常量的一种。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>const作为修饰符加在int的前面，使a成为一个具有常属性的变量，即常变量a不能再被修改，否则会报错。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>分为单精度浮点数和双精度浮点数，双精度浮点数能保留更多位小数，更精确,%f是取小数。</p>
<p>我们试一下下面的运算</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"结果为%d。\n"</span>,((a+b)/<span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里输入5，5，结果为3，没有小数</p>
<p>如果输入10 ，10，结果不是6.666…而是6，这里说明4舍5入不符合</p>
<p>这里需要知道%f是取单精度，%lf是双精度</p>
<p>我们再试一下输出小数结果</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"结果为%f。\n"</span>,((a+b)/<span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里输入5，5，结果为0.000000，又出错了</p>
<p>到这里要指出：</p>
<p>在c语言中<font color="red">两个整数的运算结果只能是整数</font>，用%d得到的是整数，用%f得不到正确结果，如果把3换成3.0，系统在计算时会把a+b的结果化为浮点数，<font color="red">浮点数间的运算就是浮点数</font>。我们再试一下</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"结果为%f。\n"</span>,((a+b)/<span class="number">3.0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里输入5，5，结果正确，为3.333333</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法笔记（Typora)</title>
    <url>/2021/08/13/first/</url>
    <content><![CDATA[<h2 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h2><h1 id="空格-内容-回车执行-ctrl-1，ctrl-0复原"><a href="#空格-内容-回车执行-ctrl-1，ctrl-0复原" class="headerlink" title="+空格+内容 回车执行/ctrl+1，ctrl+0复原"></a>+空格+内容 回车执行/ctrl+1，ctrl+0复原</h1><span id="more"></span>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h2 id="同上-ctrl-2"><a href="#同上-ctrl-2" class="headerlink" title="+同上/ctrl+2"></a>+同上/ctrl+2</h2><h2 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h2><h3 id="同上-ctrl-3"><a href="#同上-ctrl-3" class="headerlink" title="+同上/ctrl+3"></a>+同上/ctrl+3</h3><p>……</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>编号标点后有空格，回车自动添加序号,添加/删除序号，会自动补序号，两次回车或下键取消序号</p>
<p>tab降级</p>
<p>shift+tab升级</p>
<p>快捷键：ctrl+shift+[</p>
<ol>
<li></li>
<li><ol>
<li></li>
<li></li>
</ol>
</li>
<li></li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>*/-+空格+内容，升降级同有序列表</p>
<p>快捷键：ctrl+shift+]</p>
<ul>
<li>立秋<ul>
<li>网课？</li>
</ul>
</li>
</ul>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>-空格[空格]空格</p>
<ul>
<li>[ ] - [x] </li>
</ul>
<p>不如段落中添加快</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">345</th>
<th style="text-align:center">678</th>
<th style="text-align:right">91011</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>段落中插入</p>
<p>crtl+回车加行</p>
<p>|内容|内容|内容|    回车执行</p>
<h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>反引号+内容+反引号</p>
<p><code>java</code></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">C: <span class="built_in">printf</span> (<span class="string">"hello,world"</span>);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python: <span class="built_in">print</span> (<span class="string">"hello,world"</span>);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java: System.out.println(<span class="string">"hello,world!"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>ctrl+shift+i</p>
<p><code>![1]</code>(C:\Users\Acer\Pictures\1.jpg省略了一个圆括号</p>
<p>就这吧，Typora软件很方便</p>
<p>快捷键应该用于频繁使用的语法</p>
]]></content>
  </entry>
  <entry>
    <title>C语言程序设计进阶（1）</title>
    <url>/2021/09/14/fourteenth/</url>
    <content><![CDATA[<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><span id="more"></span>
<h3 id="指针的应用场景"><a href="#指针的应用场景" class="headerlink" title="指针的应用场景"></a>指针的应用场景</h3><p>1.函数返回多个值时，某些值只能通过指针返回，而传入函数的参数，实际上是需要保存带回的结果的变量</p>
<p>2.函数返回运算的状态，指针返回函数运算的结果</p>
<h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>1.数组作为函数参数时可被看作指针，数组变量就是特殊的指针</p>
<p>2.数组变量本身表达地址，可不用&amp;，但是数组的单元表达的是变量，须用&amp;</p>
<p>3.[]运算符也可以对指针做，*也可以对数组做</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">p[<span class="number">0</span>]&lt;==&gt;a[<span class="number">0</span>]</span><br><span class="line">*a=<span class="number">25</span>    </span><br></pre></td></tr></tbody></table></figure>
<p>4.数组变量是const的指针，所以不能被赋值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]&lt;==&gt;<span class="keyword">int</span> * <span class="keyword">const</span> a</span><br></pre></td></tr></tbody></table></figure>
<h2 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h2><h3 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a>指针是const</h3><p>指针不能指向其他变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> q = &amp;i;</span><br><span class="line">*q = <span class="number">26</span>; OK</span><br><span class="line">q++; ERROR</span><br></pre></td></tr></tbody></table></figure>
<h3 id="所指是const"><a href="#所指是const" class="headerlink" title="所指是const"></a>所指是const</h3><p>不能通过指针修改变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>; ERROR</span><br><span class="line">i =<span class="number">26</span>; OK</span><br><span class="line">p = &amp;j; OK</span><br></pre></td></tr></tbody></table></figure>
<p>const指针做函数参数时，函数内定义的非const的参数的值会被转换成const的值</p>
<h3 id="数组与const"><a href="#数组与const" class="headerlink" title="数组与const"></a>数组与const</h3><p>const数组表示数组内的单元变量都是const,不能被修改，且只能用如下方式初始化</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>const数组作为函数参数时可以保护数组值不被修改</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>给一个指针加1表示要让指针指向下一个变量，指针指向的应是一片连续分配的空间，如数组,否则没有意义</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line">*(p+<span class="number">1</span>)-&gt;a[<span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>指针还可以用+， +=， -， -=， —， ++</p>
<p>还可以让两个指针相减，结果为几个sizeof相对应的类型，sizeof(int)为4，结果若是5，就是两个地址相距20个字节</p>
<p>*p++可以先取结果后挪地址，适用于数组的连续操作，运行也更快</p>
<h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h2><p>一般写为NULL，NULL表示0地址更通用，0地址不能随便碰，如果给指针赋值0，一旦对该指针修改就会崩溃，</p>
<h2 id="指针的类型转换"><a href="#指针的类型转换" class="headerlink" title="指针的类型转换"></a>指针的类型转换</h2><p>void型的指针可以说是不指向什么地方的指针</p>
<p>指针也可以转换类型,下例为q通过p看i,q认为i是void型,i其实还是int型的</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=&amp;i;</span><br><span class="line"><span class="keyword">void</span> *q=(<span class="keyword">void</span>*)p;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>变量可以向malloc申请以字节为单位的空间</p>
<p>malloc用到的头文件是#include<stdlib.h>,返回的结果是void*,需要转换为自己需要的类型,用完还要用free把空间还给内存，换错了会报错，计算机可是认识变量的。。。</stdlib.h></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">......                          </span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></tbody></table></figure>
<p>以后使用时要把结构先处理好，方便找位置free</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="putchar与getchar"><a href="#putchar与getchar" class="headerlink" title="putchar与getchar"></a>putchar与getchar</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>向标准输入写一个字符，返回写了多少个字符,返回-1（EOF）表示写失败，EOF定义在stdio.h内，值为-1</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((ch=getchar())!=EOF){</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的框架可用于多组输入，在没有失败时，程序会等我们下一次输入，如果失败了，就会跳出循环</p>
<p>getchar()读取一个字符后会先putchar(ch)，输出到缓冲区，缓冲区接受到回车时会把一系列字符变为一起字符串输出（提高效率），如果没有缓冲区，我们一输入就会输出，word输出就成了wwoorrdd，在输入和输出之间有一个shell帮我们处理缓冲区</p>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *a[]={</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">    <span class="string">"World"</span></span><br><span class="line">    <span class="string">"abcdefghijk"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串数组的每一个单元都是一个指针，指向一个存放字符串的地方,有时可以代替switch case</p>
<h3 id="程序函数"><a href="#程序函数" class="headerlink" title="程序函数"></a>程序函数</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>main（）括号里其实是有参数的，argv[0]是命令本身，具体以后碰到再说</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>评论区开放！</title>
    <url>/2021/08/15/fourth/</url>
    <content><![CDATA[<h1 id="gitalk已启用"><a href="#gitalk已启用" class="headerlink" title="gitalk已启用"></a>gitalk已启用</h1><p>nexT支持gitalk,评论者只需有GitHub账号即可，账号可在github官网免费注册，注册真不麻烦，github是一个共享源码的网站，不会有安全隐患，欢迎注册/登录github留言！又白嫖了一次嘿嘿</p>
]]></content>
      <tags>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title>欲鸽又止。。。</title>
    <url>/2021/10/25/ninteenth/</url>
    <content><![CDATA[<h2 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h2><span id="more"></span>
<p>和我想的不太一样，每天的大学生活都很“充实”   ^_^    总是有一些你每天必须做又可能会忘的事，还有一些突发事件来填补你时间的空缺，到头来假期反倒是最充实的。。。</p>
<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>这些天我就像个风向标，风往哪吹，我便往哪指，抓住了许多机会，有一种错觉，又有一些顾虑。我想我还呆呆地坐在谷底，不曾给自己一个看见天外世界的机会。又或者我有了这机会，爬到半路方才发现体力不支，患得患失。</p>
<h2 id="交际"><a href="#交际" class="headerlink" title="交际"></a>交际</h2><p>在高中时，我想我为自己量身定制了一套服装，还是挺合身的，只是，衣服吗~ 再长大一些就穿不得了。我想我现在姑且算是换了身衣服，不过我仍是很关注别人的评价，之前我想，我还不够谦卑，那时的我认为谦卑当然不是卑微，而是互相尊重的表现，现在再去思考，我发现我还是不懂谦卑，因为，生活也需要一种稳态，稳态就需要调和不同的因素。乐群也好，独处也好，因人而异。个人的道德标准，足以让老子鼓盆而歌，足以让凯撒写下《沉思录》，足以让王阳明格物致知……</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我相信,</p>
<p>“那些迷途的惆怅，失败的苦痛，</p>
<p>是寄予感动的热泪，深切的同情，</p>
<p>还是给以轻蔑的微笑，辛辣的嘲讽。”</p>
<p>我相信,</p>
<p>“相信不屈不挠的努力，</p>
<p>相信战胜死亡的年轻……”</p>
<p>道阻且长，且行且歌</p>
]]></content>
      <tags>
        <tag>daily life</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网做题时遇到的细节（持续更新）</title>
    <url>/2021/08/22/ninth/</url>
    <content><![CDATA[<h2 id="1-四舍五入"><a href="#1-四舍五入" class="headerlink" title="1. 四舍五入"></a>1. 四舍五入</h2><span id="more"></span>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">单精度保留小数点后两位:a = (<span class="keyword">int</span>)(a*<span class="number">100</span>+<span class="number">0.5</span>)/<span class="number">100.0</span>;</span><br><span class="line">双精度保留小数点后两位:a = (<span class="keyword">int</span>)(a*<span class="number">10000</span>+<span class="number">0.5</span>)/<span class="number">10000.0</span>;</span><br><span class="line">正整数:(<span class="keyword">int</span>)(a+<span class="number">0.5</span>)，负整数把+换成-;</span><br><span class="line">math.h头文件里有round(...),可直接四舍五入</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-输出确定位数的小数"><a href="#2-输出确定位数的小数" class="headerlink" title="2. 输出确定位数的小数"></a>2. 输出确定位数的小数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">%<span class="number">.1</span>f   %<span class="number">.1</span>lf</span><br><span class="line"></span><br><span class="line">%<span class="number">.2</span>f   %<span class="number">.2</span>lf</span><br></pre></td></tr></tbody></table></figure>
<p>在%后加上点和位数表示要保留小数点后几位</p>
<h2 id="3-输出返回值"><a href="#3-输出返回值" class="headerlink" title="3. 输出返回值"></a>3. 输出返回值</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">int</span> a=<span class="built_in">printf</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印函数的返回值就是字符个数，\n是一个字符，要单独打印</p>
<h2 id="4-域宽"><a href="#4-域宽" class="headerlink" title="4. 域宽"></a>4. 域宽</h2><p>指存放输出数据的宽度</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%10d"</span>,a);</span><br></pre></td></tr></tbody></table></figure>
<p>printf可以使用使用格式控制串“%md”输出域宽为m的十进制整数</p>
<p>m前有0则会在空位补零</p>
<p>如果要把生日分隔成年月日，可以这样写</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span>  y,m,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%4d%2d%2d"</span>,&amp;y,&amp;m,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"year=%04d\n"</span>,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"month=%02d\n"</span>,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"date=%02d"</span>,d);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>%0指的是在单个数字前补零，如果不用，单个数字前会有空格</p>
<p>这里没有return 0也能运行，可能是编译器允许的唯一特例。</p>
<h2 id="5-进制的前导"><a href="#5-进制的前导" class="headerlink" title="5. 进制的前导"></a>5. 进制的前导</h2><p>H表示的是Hex,表示是16进制数。前导标志是0x；<br>B表示的是Bit,表示是二进制.无前导标志；<br>O表示的是Octal,也可简写为OCT表示是八进制,前导为0；<br>D表示是Decem,表示十进制。无前导标志；</p>
<p>原题让输出1234的八进制与十六进制（大写）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%#o %#X"</span>,<span class="number">1234</span>,<span class="number">1234</span>);<span class="comment">//用前导控制符</span></span><br><span class="line">  <span class="comment">//printf("0%o 0X%X",1234,1234);//自己写前导</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用#可以使前导显示，结果的大小写取决于%后x的大小写</p>
<h2 id="6-数据类型强制转换"><a href="#6-数据类型强制转换" class="headerlink" title="6.数据类型强制转换"></a>6.数据类型强制转换</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">如</span><br><span class="line">b=(<span class="keyword">int</span>)a;</span><br><span class="line">b=(<span class="keyword">char</span>)a*<span class="number">10</span>;</span><br><span class="line">b=(<span class="keyword">float</span>)a%<span class="number">10</span>;</span><br><span class="line">等等,要赋值给另一个变量，如果直接打印就不用了</span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-次方"><a href="#7-次方" class="headerlink" title="7.次方"></a>7.次方</h2><p>用到了pow函数</p>
<p>pow函数用来求x的y次幂</p>
<p>如pow(5,2);</p>
<p>结果为25</p>
<h2 id="8-根号"><a href="#8-根号" class="headerlink" title="8.根号"></a>8.根号</h2><p>形式：sqrt(…)</p>
<p>海伦公式：</p>
<p>d=(a+b+c)/2;</p>
<p>e=sqrt((d<em>(d-a)</em>(d-b)*(d-c)));</p>
<h2 id="9-EOF"><a href="#9-EOF" class="headerlink" title="9.EOF"></a>9.EOF</h2><p>在stdio.h中就规定了EOF就是-1，EOF即END OF FILE,在while循环中以EOF作为文件结束标志</p>
<p>我们常见到while(scanf(“%d”,a)!=EOF){…}</p>
<p>可用于多组输入</p>
<h2 id="10-位移运算符"><a href="#10-位移运算符" class="headerlink" title="10.位移运算符"></a>10.位移运算符</h2><p>&lt;&lt;和&gt;&gt;,通过箭头方向可以很好的辨别，分别是C语言位运算符中的左移运算符和右移运算符，如表达式13&lt;&lt;2，它的运算过程为：</p>
<p>13的用二进制（四个字节，不考虑符号）表示为，0000 0000 0000 0000 0000 0000 0000 1101，那么向左移两位，右侧补0，则变为0000 0000 0000 0000 0000 0000 0011 0100 换成十进制即变为52</p>
<p>同理，再举一个例子，如表达式25&gt;&gt;3，表示25的二进制位向右移三位，由</p>
<p>0000 0000 0000 0000 0000 0000 0001 1001 变为0000 0000 0000 0000 0000 0000 0000 0011 即十进制3</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a=<span class="number">13</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    b=<span class="number">25</span>&gt;&gt;<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为a=52，b=3</p>
<p>应用：</p>
<p>1.左移N位的本质是乘以2的N次方</p>
<p>2.右移N位的本质是除以2的N次方</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>也许今天是个不错的开始</title>
    <url>/2021/08/14/second/</url>
    <content><![CDATA[<p> 很多时候我都难以做到真正的自律，更多的时候是<strong>他律</strong>。可谁会有时间监督我呢，我无可否认我的缺陷，但我的<strong>弱点</strong>有时却可以弥补缺陷，我举几个可行度高的例子。</p>
<span id="more"></span>
<h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><p>对于我来说，去图书馆是寻找压力的方式之一。我会先略显仓促地选择好合适的座位，等到安静下来，焦虑的心已然平复，我会完全融入群体当中，这时我会把读书和学习当作理所应当的事。那些来来往往，装模做样，假装学习的人也只能凸显我的安静。我不时给自己积极的心理暗示，尽管我本来就难以呆在人多的地方，我还是努力去利用好这样宁静而又略带紧张的氛围。</p>
<p><img src="https://mz.eastday.com/22584710.jpg" alt="查看源图像"></p>
<p>当然还有<strong>线上</strong>的自习室，不过效果会差很多，最好提前约好同学结伴上线。qq自带的自习室我也曾用过，有一次学了一上午，效果还不错。</p>
<h2 id="强制锁机"><a href="#强制锁机" class="headerlink" title="强制锁机"></a>强制锁机</h2><p>这属实是无奈之举，我也曾在假期使用过，有一些app支持强制锁机，是你反悔也没有退出键的那种，不过可能会对手机正常使用，信息接受造成不可预估的影响。</p>
<p><img src="https://pic1.zhimg.com/80/v2-65e826e4d58bd6149962061acbd4608e_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="女朋友？"><a href="#女朋友？" class="headerlink" title="女朋友？"></a>女朋友？</h2><p>没错，好吧，这个我还没体验过。。。</p>
<p>不过两人共勉确实是不错的设想，也许你们有一天会明白程序员的浪漫，我暂且把dev-c++当成女友吧，今晚<strong>码</strong>上见。</p>
<p>话说今天我被强喂了不少狗粮呢[哭笑]</p>
<p><img src="https://tse1-mm.cn.bing.net/th/id/R-C.cbb4c3c2058543dcba1c9cc15f0f62a1?rik=k9pGZKFw6C8zNA&amp;riu=http%3a%2f%2fwww.wsm.cn%2fuploads%2fallimg%2f161104%2f26-161104091331.jpg&amp;ehk=lmqLW5yF0bTbg%2fKh1EQEn5FanN8wAyOrqGQNa9VLgzY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="查看源图像"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也许明天也是个不错的开始，哦不，就今天！</p>
<p><img src="https://pic4.zhimg.com/v2-b10e616220e087e44ec7766d55b3cd1d_r.jpg" alt="查看源图像"></p>
]]></content>
      <tags>
        <tag>daily life</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言程序设计进阶（2）</title>
    <url>/2021/10/10/seventeenth/</url>
    <content><![CDATA[<h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是一种用户定义的数据类型，用关键字enum以如下语法声明：</p>
<span id="more"></span>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">name</span>{</span>name1,name2,...，namen}</span><br></pre></td></tr></tbody></table></figure>
<p>枚举类型名字通常不怎么使用，要用的是大括号里的名字，这些常量符号类型为int，默认值依次为0到n，即name1为0，name2为1，最后一个常量的值也是常量的个数，也可以在声明枚举量时指定值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">name</span>{</span>name1=<span class="number">3</span>,name2,name3=<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>当需要一些可以排列起来的常量值时，定义枚举可以实现，在switch-case语句中可以<strong>用常量符号代替数字</strong>，如case name1: …;等，比定义独立的const int变量更好用</p>
<p>枚举类型是以整数做内部计算和外部输入输出的,<strong>枚举只是int</strong>，赋给枚举变量1~n以外的整数也不会有任何warning和error</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="声明结构类型的三种方式"><a href="#声明结构类型的三种方式" class="headerlink" title="声明结构类型的三种方式"></a>声明结构类型的三种方式</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">pl</span>,<span class="title">p2</span>;</span></span><br><span class="line"><span class="comment">//p1 和 p2 都是point⾥⾯有x和y的值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">}p1,p2;</span><br><span class="line"><span class="comment">//p1 和 p2都是⼀种⽆名结构，⾥⾯有x和y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//p1,p2;p1和p2都是point⾥⾯有x和y的值t</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于第⼀和第三种形式，都声明了结构point，但是第⼆种形式没有声明point，只是定义了两个变量，下面是一个用例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;<span class="comment">//通常在函数外部声明结构类型，这样就可以被多个函数所使⽤了</span></span><br><span class="line">}p1,p2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">x</span> <span class="title">y</span>;</span></span><br><span class="line">    y.a=<span class="number">1</span>;</span><br><span class="line">    y.b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,y.a,y.b);<span class="comment">//也可以用%i,在printf中二者效果一样，scanf则分进制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">x</span> <span class="title">y</span>=</span>{<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">x</span> <span class="title">k</span>=</span>{.a=<span class="number">1</span>};</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,y.a,y.b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两种初始化方式，可以仅指定某些成员初始化</p>
<h4 id="结构运算"><a href="#结构运算" class="headerlink" title="结构运算"></a>结构运算</h4><p>要访问整个结构，直接⽤结构变量的名字</p>
<p>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">p1 = (struct name){<span class="number">5</span>, <span class="number">10</span>}; <span class="comment">// 相当于p1.x = 5; p1.y = 10;</span></span><br><span class="line"> p1 = p2;<span class="comment">// 相当于p1.x = p2.x; p1.y = p2.y;</span></span><br><span class="line"><span class="comment">//(数组不能做这两种运算)</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></tbody></table></figure>
<p>必须需用&amp;，结构变量的名字不是地址，和数组区分开</p>
<h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">day</span><span class="params">(struct name a)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>整个结构可以作为参数的值传⼊函数,这时候是在函数内新建⼀个结构变量，并<strong>复制</strong>调⽤者的结构的值,这样的函数也可以<strong>返回⼀个结构</strong></p>
<h4 id="输入结构并返回"><a href="#输入结构并返回" class="headerlink" title="输入结构并返回"></a>输入结构并返回</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getstruct</span><span class="params">(struct name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outstruct</span><span class="params">(struct name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">y</span>=</span>{<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">    getstruct(y);</span><br><span class="line">    outstruct(y);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getstruct</span><span class="params">(struct name p)</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p.a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,p.a,p.b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outstruct</span><span class="params">(struct name p)</span></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,p.a,p.b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>向函数提供一个结构y，函数会在内部新建⼀个结构变量p，读入输入的结构，我们比较一下getstruct(y)和outstruct(y)打印的结构是否与输入的结构相同，显然，outstruct仍然是0，0；main()中的y没有变，也就是说输入的结构没有返回，那么如何返回呢？</p>
<p>解决方式有以下几种：</p>
<p>1.在函数中创建一个临时结构变量读入结构并返回，即return+临时结构名；</p>
<p>2.将y的地址传给函数，也就是结构指针；</p>
<h4 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>{</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">}day;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span>=</span>&amp;day;</span><br><span class="line">(*p).month=<span class="number">12</span>;</span><br><span class="line">p-&gt;month=<span class="number">12</span>;<span class="comment">//两种表述都可以，一般⽤-&gt;表⽰指针所指的结构变量中的成员</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构指针作为参数"><a href="#结构指针作为参数" class="headerlink" title="结构指针作为参数"></a>结构指针作为参数</h4><p>这会比创建一个临时结构好得多</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span> =</span> {<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">inputPoint(&amp;y);</span><br><span class="line">output(y); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct point* <span class="title">inputPoint</span><span class="params">(struct point *p)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> <span class="built_in">scanf</span>(“%d”,&amp;(p-&gt;x));</span><br><span class="line"> <span class="built_in">scanf</span>(“%d”,&amp;(p-&gt;y));</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>好处是传入传出只是⼀个指针的大小,返回传⼊的指针是⼀种套路</p>
<p>如果需要保护传入的结构不被函数修改我们可以const struct point *p</p>
<h4 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dateAndTime</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">sdate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">stime</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>访问成员时用多个.就可以了,如school.class.student1</p>
<p>如果有变量定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span>,*<span class="title">rp</span>;</span></span><br><span class="line">rp = &amp;r;</span><br></pre></td></tr></tbody></table></figure>
<p>那么下面的四种形式是等价的:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">r.pt1.x </span><br><span class="line">rp-&gt;pt1.x </span><br><span class="line">(r.pt1).x </span><br><span class="line">(rp-&gt;pt1).x</span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> {</span><br><span class="line">{<span class="number">4</span>,<span class="number">5</span>,<span class="number">2005</span>},{<span class="number">2</span>,<span class="number">4</span>,<span class="number">2005</span>}};</span><br></pre></td></tr></tbody></table></figure>
<p>每一个成员都要用大括号括起来</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门笔记（3）</title>
    <url>/2021/08/18/seventh/</url>
    <content><![CDATA[<h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>goto的使用</p>
<p>使用goto可以跳出多重循环，不建议在其他时候使用</p>
<span id="more"></span>
<img src="/2021/08/18/seventh/1.jpg" class="" title="blog">
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>&lt;类型&gt;变量名称[下标，即元素数量]</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">100</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>数组是一种容器</p>
<p>其中所有的元素具有相同的数据类型</p>
<p>一旦创建无法改变大小</p>
<p>数组各元素在内存中连续依次排列</p>
<p>可出现在赋值的左边或右边，叫做左值或右值</p>
<p>下标范围为[0，数组大小-1]，超出界限则视为<font color="red">越界</font>，容易出错却不容易报错</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>举一个求和函数的例子</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sum （ <span class="keyword">int</span> a,<span class="keyword">int</span> b )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = a;i &lt;= b; i++ ){</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line">    print (<span class="string">"%d到&amp;d的和为%d\n"</span>,a,b,sum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">sum(<span class="number">40</span>,<span class="number">50</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数头"><a href="#函数头" class="headerlink" title="函数头"></a>函数头</h3><p>其中第一行是函数头，void叫做返回类型，sum是起的函数名，括号内是参数表</p>
<p>函数头的括号起到了表示函数调用的作用，里面没有参数也不能被删去，如果有参数要给出正确的数量和顺序</p>
<p>函数可以<font color="red">简化</font>重复的程序,依次进行初始化和返回</p>
<h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>最大的代码块内是函数体</p>
<p>如果想把函数放在主函数下，要先把函数头作为<font color="red">声明</font>放在最前面，告诉编译器你创建了一个何类型，何函数名，何参数的函数，以免系统<font color="red">自上而下</font>识别到函数<font color="red">定义</font>时报错</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>return可以停止函数的执行，并送回一个值，返回的值可以赋给函数外的变量，函数内的变量与函数外的变量<font color="red">无关</font>，return可以单独使用，也可以接表达式</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>int</strong>类型的函数返回值</p>
<p>需要用return停止函数执行并返回结果</p>
<p><strong>void</strong>类型的函数不返回值，也就是说调用时不能做返回值的赋值</p>
<p>不能使用带值的return，也可以不用return</p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>调用函数时的圆括号里的逗号是标点符号，不是运算符</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">i(a,b);</span><br><span class="line">i((a,b));</span><br></pre></td></tr></tbody></table></figure>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>循环语句，判断语句可以嵌套，函数则不能嵌套</p>
<h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><p>定义在函数内部的变量都时本地变量（目前学过的都是）</p>
<h2 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h2><p>变量从出现到消失的时期</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>变量起作用的代码范围</p>
<p>对于本地变量，它的生存期和作用域就是大括号（块）</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>本地变量定义在块内，可以是函数的块，也可以是语句的块内，也可以定义在语句的块内，甚至可以随便拉一对大括号来定义变量</p>
<p>块外定义的变量在块内仍有效</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>zzuli OJ 1077：空心菱形及其延伸</title>
    <url>/2021/09/24/sixteenth/</url>
    <content><![CDATA[<h1 id="zzuli-OJ-1077：空心菱形"><a href="#zzuli-OJ-1077：空心菱形" class="headerlink" title="zzuli OJ 1077：空心菱形"></a><a href="http://acm.zzuli.edu.cn/problem.php?id=1077">zzuli OJ 1077：空心菱形</a></h1><span id="more"></span>
<p>题目描述</p>
<p>输入一个整数n，（1&lt;=n&lt;=20）,输出一个空心菱形，其中每个边由n个’*’组成</p>
<p>输入：</p>
<p>输入包含一个整数,n（1&lt;=n&lt;=20）</p>
<p>输出：</p>
<p>输出一个空心菱形，每个边由n个’*’组成</p>
<p>样例输入</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>样例输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    *</span><br><span class="line">   * *</span><br><span class="line">  *   *</span><br><span class="line"> *     *</span><br><span class="line">*       *</span><br><span class="line"> *     *</span><br><span class="line">  *   *</span><br><span class="line">   * *</span><br><span class="line">    *</span><br></pre></td></tr></tbody></table></figure>
<p>我的解法（题目没要求多组输入）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF){</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">2</span>*n<span class="number">-1</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>(j-i==n<span class="number">-1</span>||i+j==n<span class="number">-1</span>||i-j==n<span class="number">-1</span>||i+j==<span class="number">3</span>*n<span class="number">-3</span>){</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先我们会发现填*的i和j满足某种函数关系,如果输入为n,我们可用以下框架建立一个空白棋盘，然后我们只需要找到i和j在矩阵中的一种或多种关系，以及棋盘的大小范围，就能随心所欲，画出想要的图案</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF){</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;行的范围;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;列的范围;j++){</span><br><span class="line">                <span class="keyword">if</span>(i和j在矩阵中的一种或多种关系){</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="再举一个X形图案例子（牛客网bc68）"><a href="#再举一个X形图案例子（牛客网bc68）" class="headerlink" title="再举一个X形图案例子（牛客网bc68）"></a><a href="https://www.nowcoder.com/practice/83d6afe3018e44539c51265165806ee4?tpId=107&amp;&amp;tqId=33349&amp;rp=1&amp;ru=/ta/beginner-programmers&amp;qru=/ta/beginner-programmers/question-ranking">再举一个X形图案例子（牛客网bc68）</a></h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>KiKi学习了循环，BoBo老师给他出了一系列打印图案的练习，该任务是打印用“*”组成的X形图案。</p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>多组输入，一个整数（2~20），表示输出的行数，也表示组成“X”的反斜线和正斜线的长度。</p>
<h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>针对每行输入，输出用“*”组成的X形图案。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">*   *</span><br><span class="line"> * * </span><br><span class="line">  *  </span><br><span class="line"> * * </span><br><span class="line">*   *</span><br></pre></td></tr></tbody></table></figure>
<p>可以用刚刚提到的框架写：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF){</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==j||i+j==n<span class="number">-1</span>){</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你学废了吗，嘿嘿</p>
<p>可能对你来说太简单了</p>
<p>其实我们还可以用&lt; &gt;号来填充图形或镂空图形，总之，这不比嵌套的if语句简单？</p>
<p>感谢大佬的光临让本站蓬荜生辉 : )</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门笔记（2）</title>
    <url>/2021/08/17/sixth/</url>
    <content><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>一个表达式是一系列运算符和算子的组合，用来计算一个值</p>
<span id="more"></span>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>+，-，*，/,%(取余)……</p>
<p>还有</p>
<img src="/2021/08/17/sixth/344567.jpg" class="" title="blog">
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><img src="/2021/08/17/sixth/23454.jpg" class="" title="blog">
<p>举个例子:a=b=1,是先把1赋给b,再把b的值赋给a</p>
<h4 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h4><p>参与运算的值，可以是常数，变量，返回值…..</p>
<h4 id="关系运算的结果"><a href="#关系运算的结果" class="headerlink" title="关系运算的结果"></a>关系运算的结果</h4><p>成立则为1,否则为0</p>
<h4 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a>复合赋值</h4><p>有五种分别为</p>
<p>+=  -=  *=  /=  %=</p>
<p>举例: a += 1即a = a + 1</p>
<h4 id="特殊的递增递减运算符"><a href="#特殊的递增递减运算符" class="headerlink" title="特殊的递增递减运算符"></a>特殊的递增递减运算符</h4><p>++与—</p>
<p>作用是给变量加1或减1</p>
<p>举例: a++ 即 a += 1 即 a = a + 1</p>
<p>a++ 与 ++a 不一样,原因如图</p>
<img src="/2021/08/17/sixth/36745.jpg" class="" title="blog">
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行注释内容</span></span><br><span class="line"><span class="comment">  多行注释内容</span></span><br><span class="line"><span class="comment">  多行注释内容*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>高中讲过一部分,如图</p>
<img src="/2021/08/17/sixth/34565.png" class="" title="blog">
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>if的四种用法:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">if</span>(条件成立){</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span>(条件成立)</span><br><span class="line">    ...;</span><br><span class="line"><span class="comment">//也可以这样写,但要注意分号的位置</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="keyword">if</span>(条件成立){</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="keyword">if</span>(条件成立){</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>{</span><br><span class="line">...</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>{</span><br><span class="line">...</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"><span class="comment">//级联if-else if,else只和最近的那个if匹配</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">while</span> (...){</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"><span class="comment">//进循环前就需要检查条件是否满足</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">do</span> {</span><br><span class="line">...</span><br><span class="line">} <span class="keyword">while</span> (...);</span><br><span class="line"><span class="comment">//做完一轮循环后再检查条件是否满足</span></span><br><span class="line"><span class="number">3.f</span><span class="keyword">or</span> (初始动作;条件;每轮的动作) </span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"><span class="comment">//c99 only</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>如果有固定的次数,用for</p>
<p>如果必须执行一次,用do_while</p>
<p>其他情况用while</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><img src="/2021/08/17/sixth/546.jpg" class="" title="blog">
<p>true对应的值是1,false对应的值是0</p>
<p>优先级如图</p>
<img src="/2021/08/17/sixth/6543.jpg" class="" title="blog">
<p>即 非 &gt; 或 &gt; 且</p>
<h2 id="C语言中逗号的作用"><a href="#C语言中逗号的作用" class="headerlink" title="C语言中逗号的作用"></a>C语言中逗号的作用</h2><p>1.做运算符,若干式子用逗号隔开,自左向右依次运行</p>
<p>2.做分隔符,主要在for中使用,如:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (a=<span class="number">1</span>,b=<span class="number">2</span>;a&lt;b;a++,b++)......</span><br></pre></td></tr></tbody></table></figure>
<h2 id="进一步的判断"><a href="#进一步的判断" class="headerlink" title="进一步的判断"></a>进一步的判断</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (...) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: ...</span><br><span class="line">    <span class="keyword">default</span>:...</span><br><span class="line">}</span><br><span class="line"><span class="comment">//c99 only</span></span><br></pre></td></tr></tbody></table></figure>
<p>switch-case可以表示多路分支,其中编译器读到break时会跳出当前判断,因此case1,case2会一起执行,但case3不会执行,如果情况都不符,执行default</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机入门图书分享</title>
    <url>/2021/08/21/tenth/</url>
    <content><![CDATA[<h1 id="3本入门图书"><a href="#3本入门图书" class="headerlink" title="3本入门图书"></a>3本入门图书</h1><p><a href="https://pan.baidu.com/s/1wvdQ6bQqB3cdNQRzeLcrxg">https://pan.baidu.com/s/1wvdQ6bQqB3cdNQRzeLcrxg</a><br>0000</p>
<span id="more"></span>
<p>包含3本</p>
<p>1.c++primerplus6</p>
<img src="/2021/08/21/tenth/1.jpg" class="" title="blog">
<p>2.算法竞赛入门经典 紫书</p>
<img src="/2021/08/21/tenth/2.jpg" class="" title="blog">
<p>3.算法竞赛入门经典训练指南</p>
<img src="/2021/08/21/tenth/3.jpg" class="" title="blog">
]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客的原因</title>
    <url>/2021/08/15/third/</url>
    <content><![CDATA[<h1 id="搭建博客的原因"><a href="#搭建博客的原因" class="headerlink" title="搭建博客的原因"></a>搭建博客的原因</h1><p>也许是心血来潮，看到别人的博客满满都是学习编程的<strong>笔记</strong>，忍不住要试一下。也许这也算是<strong>他律</strong>了，尽管访问量不见上涨，我依旧有发博客的动力，也许只是刚开始有新鲜感（都这么说），但这东西确实上瘾。我觉得程序员的快乐来源中，成功运行程序的<strong>成就感，满足感</strong>应该是占比不少的。</p>
<span id="more"></span>
<p>也许暑假更应该了解大学，规划未来的<strong>路线</strong>，而不是继续学习许多新的知识，当然，我不否认预习的好处。</p>
<p>我已经打算<strong>考研</strong>，至少要去了解如何尽快过四六级，计算机考研考什么，考专硕还是学硕，奖学金怎么申请，面试笔试内容是什么，有哪些网站可以更好刷题，保研的条件我是否能企及……</p>
<p>我前几天又重温了2018年的华语辩论世界杯，辩题是21世纪青年人应该做加法还是减法，作为即将步入大学生活的青年，没有阅历不要紧，可以做适当的减法，到了大学，经历过便自然懂了，更应该做加法。青云姐姐的一句“趁着年轻，我偏要勉强”令我无比动容。</p>
<p><img src="http://p6.itc.cn/images01/20210112/f6c38f135f9c43c9853db7395dad59a7.jpeg" alt=""></p>
<p>只有构建好框架，才能往里面填充一些东西。博客就是一个框架，如果做的好，甚至会成为我面试时简历上的一个闪光点。</p>
<p>信息爆炸的时代，利用爬虫可以高效抓取网络信息，学习计算机，一方面是为了<strong>高薪</strong>，另一方面是让计算机成为我的大脑，让我能<strong>高效获取</strong>高质的<strong>信息</strong>。</p>
<p><img src="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202012/29/15055096ql2xdaub4r8bg7.png" alt="查看源图像"></p>
<p>话说回来，这是一个<strong>静态</strong>博客，我可以个性化布局，可以在本地写文章，网络成本低，完全<strong>免费</strong>，更适合我这种一无所知的小白。我用的是近年流行的方法，hexo部署到github,我没有期望太多访问量，所以关于链接无法被百度收录的问题也不必在乎（github禁止百度爬虫，当然有大佬也能解决）。我用的是热门的nexT主题，出问题了容易得到网络<strong>帮助</strong>。</p>
<p>经验都是<strong>坑</strong>出来的，我搭建hexo时用cmd安装不了git，又在git bash重试了一遍。</p>
<p>搭建成功的那份喜悦，让我觉得一切都值得。</p>
]]></content>
      <tags>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d发布经常出错的解决方式</title>
    <url>/2021/09/11/thirteenth/</url>
    <content><![CDATA[<h1 id="详情"><a href="#详情" class="headerlink" title="详情"></a><a href="https://blog.csdn.net/qq_32454537/article/details/81338807">详情</a></h1><p>我以前在本地写好博客，想要push到git上，通常由于网络的问题发布失败，会出现如下字样，很恶心。</p>
<span id="more"></span>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">unable to access <span class="string">'https://github.com/yujingsea/yujingsea.github.io.git/'</span>: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:<span class="number">443</span></span><br></pre></td></tr></tbody></table></figure>
<p>网上流传（我今天才在csdn找到方法）的解决方式是取消http代理</p>
<p>如果还解决不了，就要往host里添加代理了</p>
<p>打开Git Bash输入以下指令：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></tbody></table></figure>
<p>然后发布博文就没问题了</p>
]]></content>
      <tags>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛入门(C语言)(持续更新)</title>
    <url>/2021/09/10/twelfth/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法用到的C语言范围在学习指针之前,尽可能寻找每个经典问题的最优解,也想借此做好笔记,方便回顾等等</p>
<span id="more"></span>
<p>最近去牛客网做了做入门题，我在138道基础题中见到好多新奇的解题思路，于是想把我见到的算法做个简单集合，由于时间有限，部分代码就直接转载了，超链接里有原网页</p>
<img src="/2021/09/10/twelfth/1.jpg" class="" title="blog">
<img src="/2021/09/10/twelfth/2.jpg" class="" title="blog">
<h2 id="1-反向输出一个n位数"><a href="#1-反向输出一个n位数" class="headerlink" title="1.反向输出一个n位数"></a>1.反向输出一个n位数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//思路一:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	{</span><br><span class="line">        b=a%<span class="number">10</span>;</span><br><span class="line">        a=a/<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*当然也可以简化*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a%<span class="number">10</span>);</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//思路2:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%1d%1d%1d%1d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%d%d%d"</span>,d,c,b,a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-大小写转换（多组输入）"><a href="#2-大小写转换（多组输入）" class="headerlink" title="2.大小写转换（多组输入）"></a>2.大小写转换（多组输入）</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*scanf*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c\n"</span>,&amp;a)!=EOF){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a+<span class="number">32</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*getchar*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=getchar())!=EOF){</span><br><span class="line">        <span class="keyword">if</span>(ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>){</span><br><span class="line">            ch+=<span class="number">32</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-判断字母"><a href="#3-判断字母" class="headerlink" title="3.判断字母"></a>3.判断字母</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch)!=EOF){</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'\n'</span>) <span class="keyword">continue</span>;<span class="comment">//也可用getchar();</span></span><br><span class="line">        <span class="keyword">if</span>((ch&gt;=<span class="string">'a'</span>&amp;&amp;ch&lt;=<span class="string">'z'</span>)||(ch&gt;=<span class="string">'A'</span>&amp;&amp;ch&lt;=<span class="string">'Z'</span>)){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-四种排序"><a href="#4-四种排序" class="headerlink" title="4.四种排序"></a>4.四种排序</h2><p>列举四种排序：</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><a href="https://www.cnblogs.com/taltao/p/10087127.html">冒泡排序</a></h3><img src="/2021/09/10/twelfth/3.gif" class="" title="blog">
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 之前的循环已经将i个元素送到末尾，不需要再次比较，故减去，因为跟后一个元素比较，为了避免溢出，故减一</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) {</span><br><span class="line">            <span class="comment">// 如果当前的元素比后一个元素小，就交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//优化以后，加了一开关变量，因为当后面几轮的循环已经排好时，就没必要再判断了</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 之前的循环已经将i个元素送到末尾，不需要再次比较，故减去，因为跟后一个元素比较，为了避免溢出，故减一</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) {</span><br><span class="line">            <span class="comment">// 如果当前的元素比后一个元素小，就交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 有数据交换</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 没有数据交换，提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">转载自博客园</span><br><span class="line">作者Taltao</span><br></pre></td></tr></tbody></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://zhuanlan.zhihu.com/p/54235498">桶排序</a></h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;array_stu[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*把50个学生的分数分别扔到对应的桶里面去*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/*如果分数跟桶的编号一样，就把这个桶的数据增加*/</span></span><br><span class="line">            <span class="keyword">if</span>(array_stu[i] ==j)</span><br><span class="line">            {</span><br><span class="line">                array_out[j] ++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*把排序后的数据输出*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/*有些同学的分数是一样的,这里要格外注意*/</span></span><br><span class="line">        <span class="keyword">while</span>(array_out[i] &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">            array_out[i]--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">转载自知乎</span><br><span class="line">作者嵌入式Linux</span><br></pre></td></tr></tbody></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a href="https://blog.csdn.net/qq_44270296/article/details/102539421">选择排序</a></h3><img src="/2021/09/10/twelfth/4.gif" class="" title="blog">
<p>每一轮排好一个数放到最前或最后</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&lt;arr[min])</span><br><span class="line">				min = j;</span><br><span class="line">		}</span><br><span class="line">		temp = arr[i];</span><br><span class="line">		arr[i] = arr[min];</span><br><span class="line">		arr[min] = temp;</span><br><span class="line">	}</span><br><span class="line">转载自csdn</span><br><span class="line">作者one of a king</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><a href="https://blog.csdn.net/qq_44270296/article/details/102539421">插入排序</a></h3><img src="/2021/09/10/twelfth/5.gif" class="" title="blog">
<p>每一轮依次向后拿出一个数插入到前面已排好的序列中</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		temp = arr[i];</span><br><span class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j]&gt;temp)</span><br><span class="line">		{</span><br><span class="line">			arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">			j--;</span><br><span class="line">		}</span><br><span class="line">		arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">	}</span><br><span class="line">转载自csdn</span><br><span class="line">作者one of a king</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-最值"><a href="#5-最值" class="headerlink" title="5.最值"></a>5.最值</h2><p>如果只用求最值，就没必要排序了</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">max = a;</span><br><span class="line"><span class="keyword">if</span>(max &lt; b)</span><br><span class="line">max = b;</span><br><span class="line"><span class="keyword">if</span>(max &lt; c)</span><br><span class="line">max = c;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-打印字符图案"><a href="#6-打印字符图案" class="headerlink" title="6.打印字符图案"></a>6.打印字符图案</h2><p>图案太多了，如菱形，沙漏，箭形，空心三角形，X形等等。我认为利用好循环条件，什么时候输出空格，什么时候输出字符，具体在哪一个或者哪些位置输出是最重要的。</p>
<p>就举一个X形的例子</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出：</span><br><span class="line">*   *</span><br><span class="line"> * * </span><br><span class="line">  *  </span><br><span class="line"> * * </span><br><span class="line">*   *</span><br></pre></td></tr></tbody></table></figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF){</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i==j||i+j==n<span class="number">-1</span>){</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里利用了字符位置的特殊性，对角线就是字符输出的位置</p>
<p>如果想通过上下镂空金字塔拼接，太过麻烦，所以思路要尽可能简单易行</p>
<h2 id="7-最大公约数与最小公倍数"><a href="#7-最大公约数与最小公倍数" class="headerlink" title="7.最大公约数与最小公倍数"></a>7.最大公约数与最小公倍数</h2><p>最大公约数：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(a&amp;&amp;b){</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) a%=b;</span><br><span class="line">        <span class="keyword">else</span> b%=a;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>最小公倍数：</p>
<p>我们都知道（我可不知道。。。）两个数的乘积等于这两个数的最大公约数和最小公倍数的积</p>
<p>那么结果就显而易见了</p>
<h2 id="8-素数个数"><a href="#8-素数个数" class="headerlink" title="8.素数个数"></a>8.素数个数</h2><p>要判断一堆数中有几个素数，要知道如何判断一个数是素数</p>
<p>一开始我们会想判断n是否能被2到n-1的整数整除，但还有优化的余地，如果一个质数大于根号n，而n可以除尽它，那么n必然也可以除尽一个更小的质数。因此我们可以判断n是否能被2到√n间的整数整除</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=a;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="built_in">sqrt</span>(i);j+=<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="built_in">sqrt</span>(i))</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a-count<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-有序序列判断"><a href="#9-有序序列判断" class="headerlink" title="9.有序序列判断"></a>9.有序序列判断</h2><p>有序包括正序，逆序以及一连串相等的数字，反过来想，无序就是正序和逆序都出现了，所以可以这样写：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])</span><br><span class="line">            flag1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&lt;arr[i+<span class="number">1</span>])</span><br><span class="line">            flag2=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag1&amp;&amp;flag2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unsorted"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sorted"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="10-有序插入一个数"><a href="#10-有序插入一个数" class="headerlink" title="10.有序插入一个数"></a>10.有序插入一个数</h2><p>如果有n个数，可以从第（n-1）个数开始比大小，原数大就往后放，空出一个位置，到下一轮如果原数小，就可以把输入的数放到原来留出的空位了（当然也可以正着来）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;x){</span><br><span class="line">            a[i]=a[i<span class="number">-1</span>];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            a[i]=x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) a[i]=x;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(i==n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="11-删除序列指定数字"><a href="#11-删除序列指定数字" class="headerlink" title="11.删除序列指定数字"></a>11.删除序列指定数字</h2><p>可以让指定数字小于零，小于零就跳过输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(x==a[j])</span><br><span class="line">            a[j]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[k]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="12-矩阵元素定位"><a href="#12-矩阵元素定位" class="headerlink" title="12.矩阵元素定位"></a>12.矩阵元素定位</h2><p>用二维数组很方便</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>][m<span class="number">-1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="13-简单动态规划和迭代"><a href="#13-简单动态规划和迭代" class="headerlink" title="13.简单动态规划和迭代"></a>13.简单动态规划和迭代</h2><p><strong>动态规划</strong>是一种在数学、计算机科学和经济学中使用的，通过<strong>把原问题分解为相对简单的子问题</strong>的方式求解复杂问题的方法</p>
<p>下面是一个经典的走台阶的问题</p>
<p>有n个台阶，小明一次可走1个台阶或2个台阶，问有几种走法</p>
<p>我们可以试着找找<strong>规律</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">台阶数</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">…</th>
<th style="text-align:center">n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">子结构</td>
<td style="text-align:center">f(1)</td>
<td style="text-align:center">f(2)</td>
<td style="text-align:center">f(3)</td>
<td style="text-align:center">f(4)</td>
<td style="text-align:center">f(5)</td>
<td style="text-align:center">f(6)</td>
<td style="text-align:center">…</td>
<td style="text-align:center">f(n)</td>
</tr>
<tr>
<td style="text-align:center">跳法</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1+2=3</td>
<td style="text-align:center">2+3=5</td>
<td style="text-align:center">3+5=8</td>
<td style="text-align:center">5+8=13</td>
<td style="text-align:center">…</td>
<td style="text-align:center">f(n)=f(n-1)+f(n-2)</td>
</tr>
</tbody>
</table>
</div>
<p>因此我们发现解法数满足<strong>f(n)=f(n-1)+f(n-2)</strong>，这不就是是<strong>斐波那契数列</strong>么</p>
<p>下面是动态规划的解法：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        a[i]=a[i<span class="number">-2</span>]+a[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然，数组记录了多个结果，我们可以用迭代(就是可以不断地用旧的值得到新的值，直到我们想要的得到的结果)，只记三个结果：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    {</span><br><span class="line">        c=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑120oj答疑课学到的小知识</title>
    <url>/2021/11/23/twentieth/</url>
    <content><![CDATA[<h2 id="small-tips"><a href="#small-tips" class="headerlink" title="small tips"></a>small tips</h2><p>1.万能头(竞赛常用，省事)，包含所有C和C++的头文件,还有常用的max,min,sort(有sort还用什么冒泡)等函数可供直接调用</p>
<span id="more"></span>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bits/stdc++.h&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br></pre></td></tr></tbody></table></figure>
<p>2.在main函数外定义变量(全局变量)会被初始化为0，而定在main函数内的局部变量空间小，容易溢出 </p>
<p>3.在main函数外用typedef可以给数据类型起名，比如</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll</span><br></pre></td></tr></tbody></table></figure>
<p>定义变量时会少些很多，在学结构体时可省事</p>
<p>4.const double a=3.14; 意思是常变量a不能再被修改 </p>
<p>5.在c++代码中cin是输入，cout是输出 cin&gt;&gt;a&gt;&gt;b意思是先读入a,后读入b cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl同理 遇到endl会打印换行 </p>
<p>6.devc++的debug(一定要学会)，设置断点，添加变量，通过查看每一步变量值的改变来找出错误 </p>
<p>7.getchar()与putchar(…)，gets()与puts(…)</p>
<p>pta实验里好几道题的解题方法要把回车滤掉，输入某变量后，要按回车，但不要让下面的%c把回车读进去了。ch=getchar()吃掉回车</p>
<p>getchar()可以读入一个字符，putchar(ch)可以输出一个字符ch，gets与puts则是对字符串处理的函数，不遇到回车不结束，最好用下面的读入方式替换gets，因为gets并不安全</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n],str"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>另外memset函数可以清空缓冲区（string.h）</p>
<p>8._gcd可以求a,b的最大公约数</p>
<p>在algorithm头文件中（c++）</p>
<p>9.差分与前缀和</p>
<p>这两种算法属于算法的优化，可以减少时间复杂度</p>
<p>详情见<a href="https://blog.csdn.net/qq_43716778/article/details/110923411">这里</a>（滑稽）</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
